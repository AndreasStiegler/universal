/*
* Match Maker Framework
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* global require */
(function () {
    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        path = require("path");

    fluid.registerNamespace("gpii.matchMakerFramework");

    gpii.matchMakerFramework.inverseCapabilities = require("./inverseCapabilities.json");

    fluid.defaults("gpii.matchMakerFramework", {
        gradeNames: ["fluid.eventedComponent", "autoInit", "kettle.app"],
        inverseCapabilities: gpii.matchMakerFramework.inverseCapabilities,
        solutionsRegistryUrl: "",
        root: path.join(__dirname, ".."),
        matchMakerUrl: "%matchMakerPath/match",
        components: {
            solutionsRegistry: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.simpleCallbackWrapper"],
                    url: "{gpii.matchMakerFramework}.options.solutionsRegistryUrl",
                    termMap: {
                        "os": "%os",
                        "version": "%version",
                        "root": path.join(__dirname, "..")
                    }
                }
            },
            matchMakerService: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.simpleCallbackWrapper"],
                    url: "{gpii.matchMakerFramework}.options.matchMakerUrl",
                    writable: true,
                    termMap: {
                        matchMakerPath: "%matchMakerPath"
                    }
                }
            }
        },
        invokers: {
            match: {
                 funcName: "gpii.matchMakerFramework.preProcess",
                 args: ["{arguments}.0", "{arguments}.1", "{arguments}.2", "{that}.events.onPreProcessed"]
            },
            getSolutions: {
                funcName: "gpii.matchMakerFramework.getSolutions",
                args: ["{solutionsRegistry}", "{arguments}.0", "{arguments}.1", "{that}.events.onSolutions"]
            },
            matchMakerDispatcher: {
                funcName: "gpii.matchMakerFramework.matchMakerDispatcher",
                args: [ "{that}", "{requestProxy}", "{arguments}.0" ]
            }
        },
        events: {
            onSolutions: null,
            onPreProcessed: null
        },
        listeners: {
            onSolutions: "{that}.match",
            onPreProcessed: "{that}.matchMakerDispatcher"
        }
    });

    gpii.matchMakerFramework.matchMakerDispatcher = function (that, requestProxy, matchMakerPayload) {
        //TODO: some algorithm to decide the MM
        //console.log(JSON.stringify(matchMakerPayload, null, 4));
        var selectedMatchMaker = "flat";
        fluid.log("MatchMaker Framework: using the " + selectedMatchMaker + " MatchMaker");
        that.matchMakerService.set({
            matchMakerPath: that.options.matchMakers[selectedMatchMaker].url
        }, matchMakerPayload, requestProxy.events.onSuccess.fire);
    };

    /*
     * takes a solutions registry object and filters out all solutions that do not match the ones
     * reported by the device reporter.
     * TODO: rename
     */
    gpii.matchMakerFramework.filterSolutions = function (solutions, device) {
        return fluid.remove_if(fluid.copy(solutions), function (solution, solutionId) {
            // Match on device solutions.
            var matchesSolutions = fluid.find(device.solutions, function (devSolution) {
                if (devSolution.id === solutionId &&
                    (!solution.version ||
                     !devSolution.version ||
                     semver.satisfies(devSolution.version, solution.version)
                    )) {
                    return true;
                }
            });
            if (!matchesSolutions) {
                return solutions;
            }
        });
    };

    /*
    * Get call to solutionsregistry, filters based on the device reporter and fires event (4th arg) after
    */
    gpii.matchMakerFramework.getSolutions = function (solutionsRegistry, preferences, device, event) {
        var os = fluid.get(device, "OS.id"),
            version = fluid.get(device, "OS.version");
        solutionsRegistry.get({
            os: os,
            version: version
        }, function (solutions) {
            var solutions = gpii.matchMakerFramework.filterSolutions(solutions, device);
            event.fire(solutions, preferences, device);
        });
    };

    /*
     * TODO: Consider having listening to onReadyToMatch even directly
     * To be called as a result of the onReadyToMatch event.
     */
    // gpii.matchMakerFramework.match = function (solutions, preferences, device, event) {
    //     var mmpayload = gpii.matchMakerFramework.preProcess(solutions, preferences, device, event);
    //     //TODO: call whatever function is responsible for selecting the MM
    // };

    /*
    * Inverse capabilities transformations
    */
    gpii.matchMakerFramework.inferCommonTerms = function (deviceContext, preferences) {
        var irules = gpii.matchMakerFramework.inverseCapabilities;
        var togo = {};
        fluid.each(preferences.contexts, function (context, contextId) {
            var prefs = context.preferences;
            togo[contextId] = {};
            fluid.each(irules, function (rule, appId) {
                var appBlock = prefs["http://registry.gpii.net/applications/"+appId];
                if (appBlock) { //TODO: Currently we'll get an {} returned if no transformations matches settings
                    var out = fluid.model.transformWithRules(appBlock, irules[appId]);
                    togo[contextId][appId] = out;
                }
            });
        });
        return togo;
    }
    /*
     * responsible for building the input payload to the matchmaker, via a bunch of helper functions
     */
    gpii.matchMakerFramework.preProcess = function (solutions, preferences, deviceContext, event) {
        var togo = {
            preferences: preferences,
            deviceReporter: deviceContext,
            solutionsRegistry: solutions,
            activeContexts: [ //TODO calculate properly
                "gpii-default"
            ],
            environmentReporter: {}, //TODO,
            inferredCommonTerms: gpii.matchMakerFramework.inferCommonTerms(deviceContext, preferences)
        };
        event.fire(togo);
    };
})();
