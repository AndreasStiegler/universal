/*!
GPII Matchmaker Framework - Utilities for hierarchical preferences

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2014 Raising the Floor - international

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";

    var fluid = fluid || require("infusion"),
        when = when || require("when"),
        gpii = fluid.registerNamespace("gpii"),
        $ = fluid.registerNamespace("jQuery");

    fluid.registerNamespace("gpii.matchMakerFramework.hierarchicalUtils");

    //this is run for each settingshandler
    //   add capabilities to leaves array (hierarchical)
    //   find and add all inputPaths from transformations to leaves array (FLAT!!)
    gpii.matchMakerFramework.hierarchicalUtils.computeLeavesFromOneSolution = function (solution, ontologyHandler) {
        var leaves = [];
        leaves = leaves.concat(fluid.makeArray(solution.capabilities));
        var inputPaths = fluid.model.transform.collectInputPaths(solution.capabilitiesTransformations || {});
        //Input paths are flat so need to be transformed into hierarchical
        var skel = gpii.matchMakerFramework.hierarchicalUtils.pathsToSkeleton(inputPaths, true);
        var transformSpec = gpii.ontologyHandler.getTransformSpec(ontologyHandler.options.ontologyTransformSpecs, "flat", "ISO24751");
        var hskeleton = fluid.model.transformWithRules(skel, transformSpec);
        var inputPaths2 = gpii.matchMakerFramework.hierarchicalUtils.computeLeaves(hskeleton);
        leaves = leaves.concat(inputPaths2);
        return leaves;
    };

    //for each settingsHandler, run computeLeavesFromOneSolution
    //End result is a list of capabilities of the application (ie. explicit capabilities + input paths)
    gpii.matchMakerFramework.hierarchicalUtils.computeLeavesFromSolution = function (solution, ontologyHandler) {
        var leaves = [];
        leaves = leaves.concat.apply(leaves, fluid.transform(solution.settingsHandlers,
            function(settingsHandler) {
                return gpii.matchMakerFramework.hierarchicalUtils.computeLeavesFromOneSolution(settingsHandler, ontologyHandler);
            }));
        return leaves;
    };

    function computeLeavesImpl (model, path, paths) {
        fluid.each(model, function (value, key) {
            var newPath = fluid.pathUtil.composePath(path, key.toString());
            if (fluid.isPrimitive(value)) {
                paths.push(newPath);
            }
            else {
                computeLeavesImpl(value, newPath, paths);
            }
        });
    }
    //takes a object (eg. prefs set) and finds all leaves. for each leaf found the path is saved.
    //the result is an array of el-paths, one for each preference
    gpii.matchMakerFramework.hierarchicalUtils.computeLeaves = function (model) {
        var paths = [];
        computeLeavesImpl(model, "", paths);
        return paths;
    };

    //given a list of el-paths, create a object with a structure that includes all the el-paths
    gpii.matchMakerFramework.hierarchicalUtils.pathsToSkeleton = function (paths, value) {
        var togo = {};
        for (var i = 0; i < paths.length; ++ i) {
            var path = paths[i];
            var existing = fluid.get(togo, path, fluid.model.escapedGetConfig);
            if (!existing) {
                fluid.set(togo, path, value || {}, fluid.model.escapedSetConfig);
            }
        }
        return togo;
    };

    gpii.matchMakerFramework.hierarchicalUtils.sortDescending = function (numA, numB) {
        return numB - numA;
    };

    /*
    For each solution:
    paths: ie. the capabilities of the solution incl. input paths from transformation
    */
    gpii.matchMakerFramework.hierarchicalUtils.expandSolutions = function (solutions, ontologyHandler) {
        return fluid.transform(solutions, function (solution, solutionId) {
            var paths = gpii.matchMakerFramework.hierarchicalUtils.computeLeavesFromSolution(solution, ontologyHandler);
            var skeleton = gpii.matchMakerFramework.hierarchicalUtils.pathsToSkeleton(paths);

            return {
                solution: solution,
                skeleton: skeleton,  //will contain capabilities incl. inputPaths
                index: solutionId
            };
        });
    };

    gpii.matchMakerFramework.hierarchicalUtils.ontologizePreferences = function (ontologyHandler, prefs, fromView, toView) {
        return ontologyHandler.prefsToOntology(prefs, fromView, toView);
    };

    //expecting a hierarchical prefs set to be present in the payload, containing hierarchical prefs
    //returns object keyed by contexts and where the values are arrays of solutions to launch in that context
    gpii.matchMakerFramework.hierarchicalUtils.disposeSolutions2 = function (data, strategy, ontologyHandler) {
        //TODO the solrecs is pulling out common terms that are in flat mode .. they should be changed to hierarchical, I believe
        var solrecs = gpii.matchMakerFramework.hierarchicalUtils.expandSolutions(data.solutionsRegistry, ontologyHandler);
        var togo = {};
        //calculate match for each of the contexts
        fluid.each(data.hierarchicalPrefs.contexts, function (context, contextId) {
            var leaves = gpii.matchMakerFramework.hierarchicalUtils.computeLeaves(context.preferences);
            var disposed = strategy(leaves, solrecs);
            togo[contextId] = [];
            fluid.each(disposed, function(solrec, solid) {
                if (solrec.disposition === "accept") {
                    togo[contextId].push(solid);
                }
            });
        });
        return togo;
    };

    //disposed: object with keys of context-ids. Each value should be an array listing the disposed
    //solutions
    //fullModel: input to MM
    gpii.matchMakerFramework.hierarchicalUtils.buildReturnPayload = function (fullModel, disposed) {
        var togo = {
            inferredConfiguration: {}
        };
        // console.log("BRP" + JSON.stringify(disposed, null, 4));

        fluid.each(disposed, function (solArray, contextId) {
            togo.inferredConfiguration[contextId] = {
                applications: {}
            };
            var appBlock = togo.inferredConfiguration[contextId].applications;
            fluid.each(solArray, function (solutionId) {
                var content = {
                    active: true,
                    //stick all the common terms and relevant app specific settings in there
                    //so they'll be applied to this application:
                    settings: fullModel.preferences.contexts[contextId].preferences
                };
                appBlock[solutionId] = content;
                //TODO: add metadata sections
            });

            //add conditions if they exist:
            if (fullModel.preferences.contexts[contextId].conditions) {
                togo.inferredConfiguration[contextId].conditions = fullModel.preferences.contexts[contextId].conditions;
            }
        });
        return togo;
    };

        /** Returns a non-positive number indicating by how many path segments the supplied
     * path fails to index correctly into the supplied model. A return value of 0
     * indicates that the path indexes fully */
     //only used by canopy MM
    // gpii.matchMakerFramework.hierarchicalUtils.prefixLength = function (path, model) {
    //     var segs = fluid.pathUtil.parseEL(path);
    //     for (var i = 0; i < segs.length; ++ i) {
    //         var seg = segs[i];
    //         model = model[seg];
    //         if (model === undefined) {
    //             return i - segs.length;
    //         }
    //     }
    //     return 0;
    // };

    // //only used by canopyMatchMaker
    // gpii.matchMakerFramework.hierarchicalUtils.extractDispositions = function (solrecs) {
    //     var togo = [];
    //     fluid.each(solrecs, function(soln) {
    //         togo[soln.index] = soln.disposition;
    //     });
    //     return togo;
    // };



    // TODO: UNUSED FUNCTION
    // gpii.matchMakerFramework.hierarchicalUtils.makeComparator = function (leaves) {
    //     return function (solnA, solnB) {
    //         var domA = false, domB = false;
    //         for (var i = 0; i < leaves.length; ++ i) {
    //             var leaf = leaves[i];
    //             var goodA = gpii.matchMakerFramework.hierarchicalUtils.prefixLength(leaf, solnA.solution);
    //             var goodB = gpii.matchMakerFramework.hierarchicalUtils.prefixLength(leaf, solnB.solution);
    //             if (goodA > goodB) {
    //                 domA = true;
    //             }
    //             else if (goodB > goodA) {
    //                 domB = true;
    //             }
    //         }
    //         return domA ^ domB? (domA? 1 : -1) : 0;
    //     };
    // };
})();