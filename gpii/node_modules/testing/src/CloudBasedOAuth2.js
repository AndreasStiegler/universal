/*!
GPII Cloud-based Flow Manager with OAuth2 Test Infrastructure

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2013 Raising the Floor
Copyright 2014 Lucendo Development Ltd.

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict";

var fluid = require("infusion"),
    querystring = require("querystring"),
    urlModule = require("url"),
    gpii = fluid.registerNamespace("gpii"),
    $ = fluid.registerNamespace("jQuery"),
    jqUnit = fluid.registerNamespace("jqUnit"),
    kettle = fluid.registerNamespace("kettle");

fluid.registerNamespace("gpii.test.cloudBased.oauth2");

gpii.test.cloudBased.oauth2.populateDataStoreUsers = function (dataStore, testCaseHolder) {
    var users = fluid.copy(dataStore.model.users);
    users[0].gpiiToken = testCaseHolder.options.userToken;
    dataStore.applier.change("users", users);
};

fluid.defaults("gpii.test.cloudBased.oauth2.testCaseHolder", {
    gradeNames: ["kettle.test.testCaseHolder", "autoInit"],
    distributeOptions: [{
        record: "gpii.oauth2.dataStore.acceptanceData",
        target: "{that gpii.oauth2.dataStore}.options.gradeNames"
    }, {
        record: {
            funcName: "gpii.test.cloudBased.oauth2.populateDataStoreUsers",
            args: ["{dataStore}", "{testCaseHolder}"]
        },
        target: "{that gpii.oauth2.dataStore}.options.listeners.onCreate"
    }],
    members: {
        encodedLogin: {
            expander: {
                func: "gpii.test.cloudBased.oauth2.encodeLogin",
                args: ["{testCaseHolder}.options.username", "{testCaseHolder}.options.password"]
            }
        }
    },
    components: {
        authorizeRequest: {
            type: "kettle.test.request.httpCookie",
            options: {
                path: "/authorize?response_type=code&client_id=%client_id&redirect_uri=%redirect_uri&state=%state",
                port: 8081,
                termMap: {
                    client_id: "{testCaseHolder}.options.client_id",
                    redirect_uri: "{testCaseHolder}.options.redirect_uri",
                    state: "{testCaseHolder}.options.state"
                }
            }
        },
        loginRequest: {
            type: "kettle.test.request.httpCookie",
            options: {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                path: "/login",
                port: 8081,
                method: "POST"
            }
        },
        authorizeRequest2: {
            type: "kettle.test.request.httpCookie",
            options: {
                path: "/authorize?response_type=code&client_id=%client_id&redirect_uri=%redirect_uri&state=%state",
                port: 8081,
                termMap: {
                    client_id: "{testCaseHolder}.options.client_id",
                    redirect_uri: "{testCaseHolder}.options.redirect_uri",
                    state: "{testCaseHolder}.options.state"
                }
            }
        },
        decisionRequest: {
            type: "kettle.test.request.httpCookie",
            options: {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                path: "/authorize_decision",
                port: 8081,
                method: "POST"
            }
        },
        accessTokenRequest: {
            type: "kettle.test.request.http",
            options: {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded"
                },
                path: "/access_token",
                port: 8081,
                method: "POST" 
            }         
        },
        securedSettingsRequest: {
            type: "kettle.test.request.http",
            options: {
                path: "/settings",
                port: 8081,
                method: "GET" 
            }         
        }
    }
});

gpii.test.cloudBased.oauth2.encodeLogin = function (username, password) {
    return querystring.stringify({username: username, password: password});
};


/** Parses a URL using the node.js url.parse algorithm, and assembles it into a JSON
 * structure holding keys:
 *     "" : holding the concatenation of "protocol", "host" and "pathname" portions as specified in url.parse
 *  others: holding the keys and values for any query parameters, as parsed by the querystring algorithm
 * This structure is then checked against the "expected" structure using the jqUnit.assertLeftHand algorithm
 * which checks that every element specified in "expected" is present but ignores any extra elements
 * @param message {String} A message to be supplied for this assertion
 * @param expected {Object/String} A object map of the required contents of the URL as described above, or if a String
 * value, tested with exact string equality
 * @param url {String} The url to be tested by this assertion
 * @return {Object/String} according to the type of `expected`, either the full assembled parsed URL structure or the original URL
 */
gpii.test.assertURL = function (message, expected, url) {
    console.log("Testing url " + url);
    if (typeof(expected) === "string") {
        jqUnit.assertEquals(message, expected, url);
        return url;
    } else {
        var parsed = urlModule.parse(url, true);
        var assembled = $.extend({
            "": parsed.protocol + "//" + parsed.host + parsed.pathname
        }, parsed.query);
        jqUnit.assertLeftHand(message, expected, assembled);
        return assembled;
    }
};

gpii.test.verifyRedirectResponse = function (request, location) {
    var response = request.nativeResponse;
    console.log("Got redirect to " + response.headers.location);
    jqUnit.assertEquals("Should have received a 302 redirect", 302, response.statusCode);
    return gpii.test.assertURL("Should have been redirected to " + location, location, response.headers.location);
};

gpii.test.cloudBased.oauth2.verifyLoginRedirect = function (request, cookieJar) {
    gpii.test.verifyRedirectResponse(request, "/login");
    jqUnit.assertValue("Should have stored a cookie received from server", cookieJar.cookie);
};

gpii.test.cloudBased.oauth2.verifyAuthorizeRedirect = function (loginRequest, authorizeRequest) {
    gpii.test.verifyRedirectResponse(loginRequest, authorizeRequest.nativeRequest.path)
    var response = loginRequest.nativeResponse;
    jqUnit.assertTrue("Should have been redirected to an /authorize URL", response.headers.location.indexOf("/authorize") === 0);
};

gpii.test.cloudBased.oauth2.sendAuthorizeRequest2 = function (authorizeRequest2, loginRequest) {
    authorizeRequest2.send({
        path: loginRequest.nativeResponse.headers.location
    });
};

gpii.test.verifyHTMLResponse = function (body, request) {
    var response = request.nativeResponse;
    jqUnit.assertEquals("Should have received a 200 response", 200, response.statusCode);
    jqUnit.assertTrue("Should have received an HTML response type", response.headers["content-type"].indexOf("text/html") === 0);
    jqUnit.assertTrue("Should have received HTML content as body", body.indexOf("<html>") !== -1);
};

gpii.test.verifyJSONResponse = function (body, request) {
    var response = request.nativeResponse;
    jqUnit.assertEquals("Should have received a 200 response", 200, response.statusCode);
    jqUnit.assertTrue("Should have received an JSON response type", response.headers["content-type"].indexOf("application/json") === 0);
    return JSON.parse(body);
};

// The current decision UI renders the transaction ID as part of a JSON block supplied
// to an init block within the markup (code is within AuthServer.js line 344, template
// is in authorize.handlebars) - this function needs to track the particular scheme used
// within this UI
gpii.test.cloudBased.oauth2.extractTransactionID = function (body) {
    return body.match(/transactionID:\s*"(.*)"/);
}

gpii.test.cloudBased.oauth2.verifyAuthorizeResponse = function (body, authorizeRequest) {
    gpii.test.verifyHTMLResponse(body, authorizeRequest);
    var transactions = gpii.test.cloudBased.oauth2.extractTransactionID(body);
    jqUnit.assertEquals("Should have matched 1 transaction ID", 2, transactions.length);
    authorizeRequest.transactionID = transactions[1]; // entry 0 represents entire match
};

gpii.test.cloudBased.oauth2.sendDecisionRequest = function (decisionRequest, authorizeRequest) {
    var formBody = {
        transaction_id: authorizeRequest.transactionID, 
        accept: true
    };
    decisionRequest.send(querystring.stringify(formBody));
};

gpii.test.cloudBased.oauth2.verifyDecisionResponse = function (decisionRequest, clientURL, clientState) {
    var redirect = gpii.test.verifyRedirectResponse(decisionRequest, {
        "": clientURL,
        state: clientState
    });
    jqUnit.assertValue("Should have received authorization code as query parameter", redirect.code);
    decisionRequest.authorizationCode = redirect.code;
};

gpii.test.cloudBased.oauth2.sendAccessTokenRequest = function (accessTokenRequest, decisionRequest, options) {
    var formBody = { // TODO: check that this request will fail on all possible omissions from this structure
        grant_type: "authorization_code",
        code: decisionRequest.authorizationCode,
        redirect_uri: options.redirect_uri,
        client_id: options.client_id,
        client_secret: options.client_secret
    };
    
    accessTokenRequest.send(querystring.stringify(formBody));
};

gpii.test.cloudBased.oauth2.verifyAccessTokenResponse = function (body, accessTokenRequest) {
    var response = gpii.test.verifyJSONResponse(body, accessTokenRequest);
    var token = response.access_token;
    jqUnit.assertValue("Should have received an access token", token);
    console.log("Got access token ", token);
    accessTokenRequest.accessToken = token;
};

gpii.test.cloudBased.oauth2.sendSecuredSettingsRequest = function (securedSettingsRequest, accessTokenRequest) {
    securedSettingsRequest.send(null, {
        headers: {
            Authorization: "Bearer " + accessTokenRequest.accessToken
        }
    });
};

gpii.test.cloudBased.oauth2.verifySecuredSettingsResponse = function (body, securedSettingsRequest, expected) {
    var response = gpii.test.verifyJSONResponse(body, securedSettingsRequest);
    jqUnit.assertDeepEq("Expected settings returned from flowManager", expected, response);
};

gpii.test.cloudBased.oauth2.buildTestFixture = function (testDef, commonRec, baseDir) {
	testDef = $.extend(true, testDef, commonRec);
    testDef.expect = 19;
    testDef.sequence = fluid.makeArray(testDef.sequence);
    testDef.gradeNames = fluid.makeArray(testDef.gradeNames);
    testDef.gradeNames.push("gpii.test.cloudBased.oauth2.testCaseHolder");

    testDef.sequence.unshift({
        func: "{authorizeRequest}.send"
    }, {
        event: "{authorizeRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyLoginRedirect",
        args: ["{authorizeRequest}", "{cookieJar}"]
    }, {
        func: "{loginRequest}.send",
        args: "{testCaseHolder}.encodedLogin"
    }, {
        event: "{loginRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyAuthorizeRedirect",
        args: ["{loginRequest}", "{authorizeRequest}"]
    }, {
        func: "gpii.test.cloudBased.oauth2.sendAuthorizeRequest2",
        args: ["{authorizeRequest2}", "{loginRequest}"]
    }, {
        event: "{authorizeRequest2}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyAuthorizeResponse",
        args: ["{arguments}.0", "{authorizeRequest2}"]
    }, {
        func: "gpii.test.cloudBased.oauth2.sendDecisionRequest",
        args: ["{decisionRequest}", "{authorizeRequest2}"]
    }, {
        event: "{decisionRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyDecisionResponse",
        args: ["{decisionRequest}", "{testCaseHolder}.options.redirect_uri",
            "{testCaseHolder}.options.state"]
    }, {
        func: "gpii.test.cloudBased.oauth2.sendAccessTokenRequest",
        args: ["{accessTokenRequest}", "{decisionRequest}", "{testCaseHolder}.options"]
    }, {
        event: "{accessTokenRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifyAccessTokenResponse",
        args: ["{arguments}.0", "{accessTokenRequest}"]
    },{
        func: "gpii.test.cloudBased.oauth2.sendSecuredSettingsRequest",
        args: ["{securedSettingsRequest}", "{accessTokenRequest}"]
    }, {
        event: "{securedSettingsRequest}.events.onComplete",
        listener: "gpii.test.cloudBased.oauth2.verifySecuredSettingsResponse",
        args: ["{arguments}.0", "{securedSettingsRequest}", "{testCaseHolder}.options.expected"]
    });
    testDef.config = gpii.test.cloudBased.gpiiConfig(baseDir);

    return testDef;
};

gpii.test.cloudBased.oauth2.bootstrap = function (testDefs, commonRec, baseDir) {
    return kettle.test.bootstrapServer(testDefs, function (testDef) {
        return gpii.test.cloudBased.oauth2.buildTestFixture(testDef, commonRec, baseDir);
    });
};