/**
 * GPII Testing (full lifecycle of FlowManager)
 *
 * Copyright 2013 Raising the Floor International
 * Copyright 2013 OCAD University
 * Copyright 2014 Lucendo Development Ltd.
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/gpii/universal/LICENSE.txt
 *
 */

"use strict";

var fluid = require("infusion"),
    jqUnit = fluid.require("jqUnit"),
    path = require("path"),
    kettle = fluid.registerNamespace("kettle"),
    gpii = fluid.registerNamespace("gpii");


fluid.defaults("gpii.test.common.exec", {
    gradeNames: ["autoInit", "fluid.eventedComponent"],
    events: {
        onExecExit: null
    },
    invokers: {
//        exec:
    }
});


// Low-quality utility to force resolution of a value which is known to be either
// a plain value or a synchronous promise
gpii.test.resolveSync = function (response) {
    if (fluid.isPromise(response)) {
        response.then(function (resolved) {
            response = resolved;
        });
    }
    return response;
};

gpii.test.getSettings = function (payload, nameResolver) {
    var ret = {};
    fluid.each(payload, function (handlerBlock, handlerID) {
        var resolvedName = nameResolver ? nameResolver.resolveName(handlerID, "settingsHandler") : handlerID;
        var response = fluid.invokeGlobalFunction(resolvedName + ".get", [handlerBlock]);
        // TODO: We assume that every settingsHandler GET method is synchronous, even if SET is async
        ret[handlerID] = gpii.test.resolveSync(response);
    });
    return ret;
};

gpii.test.removeOptionsBlocks = function (payload) {
    var togo = fluid.copy(payload);
    return fluid.transform(togo, function (settingHandler) {
        return fluid.transform(settingHandler, function (solutionBlocks) {
            return fluid.transform(solutionBlocks, function (solutionBlock) {
                return {settings: solutionBlock.settings};
            });
        });
    });
};

gpii.test.snapshotSettings = function (settingsHandlers, settingsStore, nameResolver) {
    settingsStore.orig = gpii.test.getSettings(settingsHandlers, nameResolver);
};

gpii.test.loginRequestListen = function (data) {
    jqUnit.assertNotEquals("Successful login message returned " + data, -1,
        data.indexOf("was successfully logged in."));
};

gpii.test.checkConfiguration = function (settingsHandlers, nameResolver) {
    var config = gpii.test.getSettings(settingsHandlers, nameResolver);
    var noOptions = gpii.test.removeOptionsBlocks(settingsHandlers);
    jqUnit.assertDeepEq("Checking that settings are set", noOptions, config);
};

gpii.test.onExecExit = function (result, processSpec) {
    jqUnit.assertTrue("Checking the process with command: " + processSpec, result);
};

gpii.test.logoutRequestListen = function (data) {
    jqUnit.assertNotEquals("Successful logout message returned " + data, -1,
        data.indexOf("was successfully logged out."));
};

gpii.test.checkRestoredConfiguration = function (settingsHandlers, settingsStore, nameResolver) {
    var currentSettings = gpii.test.getSettings(settingsHandlers, nameResolver);
    jqUnit.assertDeepEq("Checking that settings are properly reset",
        settingsStore.orig, currentSettings);
};

fluid.defaults("gpii.test.common.testCaseHolder", {
    gradeNames: ["kettle.test.testCaseHolder", "autoInit"],
    members: {
        settingsStore: {}
    },
    components: {
        logoutRequest: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    path: "/user/%token/logout",
                    port: 8081
                },
                termMap: {
                    token: "{tests}.options.token"
                }
            }
        },
        loginRequest: {
            type: "kettle.test.request.http",
            options: {
                requestOptions: {
                    path: "/user/%token/login",
                    port: 8081
                },
                termMap: {
                    token: "{tests}.options.token"
                }
            }
        }
    }
});

gpii.test.buildSingleTestFixture = function (testDef, rootGrades) {
    var processes = testDef.processes || [];
    testDef.gradeNames = fluid.makeArray(testDef.gradeNames).concat(fluid.makeArray(rootGrades));

    testDef.expect = 4 + processes.length * 2;
    testDef.sequence = fluid.makeArray(testDef.sequence);

    testDef.sequence.unshift({
        func: "gpii.test.snapshotSettings",
        args: ["{tests}.options.settingsHandlers", "{tests}.settingsStore", "{nameResolver}"]
    }, {
        func: "{loginRequest}.send"
    }, {
        event: "{loginRequest}.events.onComplete",
        listener: "gpii.test.loginRequestListen"
    }, {
        func: "gpii.test.checkConfiguration",
        args: ["{tests}.options.settingsHandlers", "{nameResolver}"]
    });

    // For each process, run the command, then check that we get the expected output
    fluid.each(processes, function (process, pindex) {
        testDef.sequence.push({
            func: "{exec}.exec",
            args: [
                fluid.model.composeSegments("{tests}.options.processes", pindex),
                fluid.model.composeSegments("{tests}.options.processes", pindex, "expectConfigured")
            ]
        }, {
            event: "{exec}.events.onExecExit",
            listener: "gpii.test.onExecExit"
        });
    });

    testDef.sequence.push({
        func: "{logoutRequest}.send"
    }, {
        event: "{logoutRequest}.events.onComplete",
        listener: "gpii.test.logoutRequestListen"
    });

    // Check that the processes are in the expected state after logout
    fluid.each(processes, function (process, pindex) {
        testDef.sequence.push({
            func: "{exec}.exec",
            args: [
                fluid.model.composeSegments("{tests}.options.processes", pindex),
                fluid.model.composeSegments("{tests}.options.processes", pindex, "expectRestored")
            ]
        }, {
            event: "{exec}.events.onExecExit",
            listener: "gpii.test.onExecExit"
        });
    });

    testDef.sequence.push({
        func: "gpii.test.checkRestoredConfiguration",
        args: ["{tests}.options.settingsHandlers", "{tests}.settingsStore", "{nameResolver}"]
    });

    return testDef;
};


// Convert a record as returned by a "portable test" into a full testDefs structure as accepted by gpii.test.buildTests
gpii.test.recordToTestDefs = function (record, baseDir) {
    var testDefs = fluid.copy(fluid.getGlobalValue(record.testDefs));
    fluid.each(testDefs, function (testDef) {
        testDef.config = {
            configName: record.configName,
            configPath: path.resolve(baseDir, record.configPath)
        };
    });
    return testDefs;
};

gpii.test.runTests = function (record, baseDirName, rootGrades) {
    var testDefs = gpii.test.recordToTestDefs(record, baseDirName);
    var testDefs2 = gpii.test.buildTests(testDefs, rootGrades);
    return kettle.test.bootstrapServer(testDefs2);
};

// Run from the base of every platform-specific test fixture file as its per-file bootstrap.
// The long argument list is required in order to detect whether the file is being run as a top-level
// node executable - if it is, we default to running it as an integration test - otherwise, we just
// return its record.

gpii.test.bootstrap = function (record, rootGrades, foreignModule, foreignRequire, foreignDirName) {
    if (foreignRequire.main === foreignModule) { // the file was executed directly from the command line - run integration tests immediately
        return gpii.test.runTests(record, foreignDirName, rootGrades);
    } else { // otherwise just return its record for processing
        return record;
    }
};

gpii.test.buildTests = function (testDefs, rootGrades) {
    return fluid.transform(fluid.copy(testDefs), function (testDef) {
        return gpii.test.buildSingleTestFixture(testDef, rootGrades);
    });
};

/** Runs a suite of integration or acceptance tests as indexed by a platform-specific root
 * such as "index-windows.js".
 * @param files {Array} the array of test fixture files, as returned by the index module
 * @param baseDir {String} the base directory holding the index module
 * @param rootGrades {Array} an array of grade names to be contributed to the component root
 * (currently testCaseHolder) of the fixtures. This controls the variety of test which is executed - 
 * e.g. a mocked Windows environment integration test, or a full acceptance test (the default)
 */

gpii.test.runSuite = function (files, baseDir, rootGrades) {
    fluid.log("Running test suites:\n", JSON.stringify(files, null, 2));
    fluid.each(files, function (oneFile) {
        var filePath = path.resolve(baseDir, "platform", oneFile);
        var fileDir = path.dirname(filePath);
        var record = require(filePath);
        gpii.test.runTests(record, fileDir, rootGrades);
    });
};

// simple utility to select a set of test suites to run based on presence of substrings in their names
gpii.test.filterSuites = function (files, specs) {
    var selected = [];
    fluid.each(specs, function (spec) {
        fluid.each(files, function (file, index) {
            if (file.indexOf(spec) !== -1) {
                selected[index] = true;
            }
        });
    });
    return fluid.remove_if(fluid.copy(files), function (file, index) {
        return !selected[index];
    });
};

gpii.test.filterSuitesByArgs = function (files, args) {
    return args.length === 2 ? files : gpii.test.filterSuites(files, args.slice(2));
};

gpii.test.runSuitesWithFiltering = function (files, baseDir, rootGrades) {
    var filtered = gpii.test.filterSuitesByArgs(files, process.argv);
    gpii.test.runSuite(filtered, baseDir, rootGrades);
};