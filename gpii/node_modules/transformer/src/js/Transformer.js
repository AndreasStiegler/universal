/*!
GPII Settings Transformer

Copyright 2012 OCAD University
Copyright 2012 Antranig Basman
Copyright 2013-2014 Raising the Floor

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

"use strict";

var fluid = fluid || require("infusion"),
    $ = fluid.registerNamespace("jQuery"),
    gpii = fluid.registerNamespace("gpii");

(function () {

    fluid.defaults("gpii.transformer", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        invokers: {
            settingsHandlerToLifecycle: {
                funcName: "gpii.transformer.toLifecycleFormat",
                args: [ "{arguments}.0", "{arguments}.1" ]
            }
        }
    });

    /*
     * helper function for `gpii.transformer.toLifecycleFormat`. Used to modify the settings handler
     * blocks to be in the format required (ie. including the application specific settings to be
     * set) by the lifecycle manager
     *
     * @settingsHandler (Object) - The settingshandler to be modified. Note that this object will be
     *     modified - not just a copy of it.
     * @preferences (Object) - the user preferences related to this solution and settings handler.
     * @solutionId (Object) - the ID of the solution for which the settingshandler is related
     *
     * @return (Object) - the modified settingshandler object - ready to be passed to the lifecycle
     *     manager
     */
    gpii.transformer.settingsHandlerToLifecycle = function (settingsHandler, preferences, solutionId) {
        // todo: throw app specific settings in the correct locations if there are multiple handlers
        var settings = preferences.settings["http://registry.gpii.net/applications/" + solutionId];
        var inferred;
        if (settingsHandler.capabilitiesTransformations) {
            inferred = fluid.model.transformWithRules(preferences.settings, settingsHandler.capabilitiesTransformations);
            settings = $.extend(true, inferred, settings);
        }

        settingsHandler.settings = settings;
        delete settingsHandler.capabilitiesTransformations;
        delete settingsHandler.capabilities;
        return settingsHandler;
    };

    /*
     * Modifies a system configuration (output from the context manager) to a format readible by the
     * lifecycle manager. This includes translation common terms to application specific settings.
     * The following rules apply when doing this translation:
     * - the translation is based on the transformations in the solutionsRegistry entry
     * - if a common term transforms into a setting which is already specific as applicaiton speicfic
     *      in the configuration parameter, the application specific takes priority. In other words:
     *      if the configuration contains both an application specific and (transformable) common
     *       term for some application setting, the application specific one will stay and the
     *      transformed will be discarded.
     *
     * @configuration (Object) - An object, which has already been evaluated with regards to context
     *      (by the context manager)
     * @solutionsRegistry (Object) - the solutions registry database
     *
     * @returns the modified solutions registry entries, ready to be applied by the lifecycle manager.
     */
    gpii.transformer.toLifecycleFormat = function (configuration, solutionsRegistry) {
        var togo = {};
        fluid.each(configuration.applications, function (preferences, solutionId) {
            togo[solutionId] = fluid.copy(solutionsRegistry[solutionId]);
            delete togo[solutionId].contexts;
            var registryEntry = togo[solutionId];
            fluid.transform(registryEntry.settingsHandlers, function (settingsHandler) {
                return gpii.transformer.settingsHandlerToLifecycle(settingsHandler, preferences, solutionId);
            });
            // TODO: take launching, etc., into consideration

        });

        return togo;
    };



    fluid.defaults("gpii.transformer.quantize", {
        gradeNames: "fluid.standardTransformFunction"
    });

    gpii.transformer.quantize = function (value, transformSpec, transform) {
        if (!transformSpec.ranges || !transformSpec.ranges.length) {
            fluid.fail("gpii.transformer.quantize should have a key called ranges containing an array defining ranges to quantize");
        }
        for (var i = 0; i < transformSpec.ranges.length; i++) {
            var rangeSpec = transformSpec.ranges[i];
            if (rangeSpec.upperBound === undefined || value <= rangeSpec.upperBound) {
                // note that we might return undefined if output evaluates to that on an expand
                return fluid.isPrimitive(rangeSpec.output) ? rangeSpec.output : transform.expand(rangeSpec.output);
            }
        }
    };

    fluid.defaults("gpii.transformer.booleanToNumber", {
        gradeNames: "fluid.standardTransformFunction"
    });

    gpii.transformer.booleanToNumber = function (value) {
        return value ? 1 : 0;
    };

    /**
     * inRange transformer checks whether a value is within a given range and returns true if it is,
     * and false if it's not.
     *
     * The range is defined by the two inputs: "min" and "max" (both inclusive). If one of these inputs
     * is not present it is considered -infinite and +infinite, respectively - In other words, if no
     * `min` value is defined, any value below or equal to the given "max" value will result in true.
     */
    fluid.defaults("gpii.transformer.inRange", {
        gradeNames: "fluid.standardTransformFunction"
    });

    gpii.transformer.inRange = function (value, transformSpec) {
        return (transformSpec.min === undefined || transformSpec.min <= value) &&
            (transformSpec.max === undefined ||  transformSpec.max >= value) ? true : false;
    };


    /**
     * timeInRange is implemented specifically for checking whether an input time falls in between
     * two given times. The valid and required inputs, besides the standard input/inputPath are `to`
     * and `from`. All inputs should be strings of the type "hh:mm" (eg. "17:30"). The range wraps
     * midnight, so given a `from` of "20:00" and a `to` of `"08:00"` all the following inputs would
     * result in true: "20:00", 23:00", "02:45".
     */
    fluid.defaults("gpii.transformer.timeInRange", {
        gradeNames: "fluid.standardTransformFunction"
    });


    gpii.transformer.timeInRange = function (value, transformSpec) {
        var timeInRange = gpii.transformer.timeInRange;
        var currentTime = timeInRange.timeParser(value);
        var fromTime = timeInRange.timeParser(transformSpec.from);
        var toTime = timeInRange.timeParser(transformSpec.to);

        if (timeInRange.isEarlier(toTime, fromTime)) { // if time wraps
            return (timeInRange.isEarlier(fromTime, currentTime) || timeInRange.isEarlier(currentTime, toTime));
        } else {
            return (timeInRange.isEarlier(fromTime, currentTime) && timeInRange.isEarlier(currentTime, toTime));
        }
    };

    gpii.transformer.timeInRange.timeParser = function (time) {
        time = time.split(":");
        return {
            hours: parseInt(time[0], 10),
            minutes: parseInt(time[1], 10)
        };
    };

    // checks whether 'first' is earlier than 'second' - returns true if so
    gpii.transformer.timeInRange.isEarlier = function (first, second) {
        return (60 * (first.hours - second.hours) + first.minutes - second.minutes) < 0;
    };


}());
