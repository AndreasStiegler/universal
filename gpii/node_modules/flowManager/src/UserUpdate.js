/**
 * GPII User Update Handler
 *
 * Copyright 2013 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * You may obtain a copy of the License at
 * https://github.com/gpii/universal/LICENSE.txt
 */

(function () {

    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        $ = fluid.registerNamespace("jQuery");

    fluid.registerNamespace("gpii.request.flowManager");

    fluid.defaults("kettle.requests.request.handler.userUpdate", {
        gradeNames: ["gpii.request.flowManager.sessionAware", "gpii.request.flowManager.token", "autoInit"],
        invokers: {
            handle: {
                funcName: "gpii.request.flowManager.userUpdateHandle",
                args: [
                    "{flowManager}.matchMakerDataSource",
                    "{requestProxy}.events.onSuccess",
                    "{request}",
                    "{flowManager}.transformer",
                    "{flowManager}.lifecycleManager",
                    "{that}"
                ],
                dynamic: true
            },
            onMatchHandler: {
                funcName: "gpii.request.flowManager.onMatchUpdateHandler",
                args: [
                    "{flowManager}.lifecycleManagerServerDataSource",
                    "{requestProxy}.events.onSuccess",
                    "{request}", "{that}",
                    "{arguments}.0"
                ],
                dynamic: true
            }
        },
        listeners: {
            onMatch: "{that}.onMatchHandler"
        }
    });

    // TODO: this needs to be replaced with the implementation based on
    // FLUID-3674 once it's part of Infusion.
    gpii.request.flowManager.deepEq = function (obj1, obj2) {
        var equal = true;
        if (!obj2) {
            return !equal;
        }
        fluid.each(obj1, function (val, key) {
            if (fluid.isPrimitive(val)) {
                equal = val === obj2[key];
            } else {
                equal = gpii.request.flowManager.deepEq(val, obj2[key]);
            }
            return equal;
        });
        return equal;
    };

    // gpii.request.flowManager.getUpdatedPreferences = function (newPreferences, oldPreferences) {
    //     var togo = fluid.copy(newPreferences);
    //     fluid.remove_if(togo, function (val, key) {
    //         if (fluid.isPrimitive(val)) {
    //             return val === oldPreferences[key];
    //         } else {
    //             return gpii.request.flowManager.deepEq(val, oldPreferences[key]);
    //         }
    //     });
    //     return togo;
    // };

    gpii.request.flowManager.userUpdateHandle = function (matchMakerDataSource, event, fluidRequest, transformer, lifecycleManager, that) {
        that.withSession(function (session) {
            var updatedConfig = $.extend(true, {}, session.appliedConfiguration, { applications: fluidRequest.data });

            var lifecycleInstructions = transformer.settingsHandlerToLifecycle(updatedConfig, session.solutionsRegistry);
            lifecycleManager.update({ token: session.token }, lifecycleInstructions, function (response) {
                if (response.success) {
                    // Update the session.
                    session.appliedConfiguration = updatedConfig;
                }
                gpii.request.flowManager.logAndNotify("Lifecycle manager returned: ", event)(response);
            });
            // event.fire);
            //     update: {
            //     funcName: "gpii.lifecycleManager.update",
            //     args: ["{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
            // }                     // options, solutions, callback

            // fluidRequest.updatedPreferences = gpii.request.flowManager.getUpdatedPreferences(
            //     fluidRequest.data, session.preferences);
            // gpii.request.flowManager.getMatch(matchMakerDataSource, event,
            //     fluidRequest.updatedPreferences, session.device);
        });
    };

    gpii.request.flowManager.onMatchUpdateHandler = function (lifecycleManagerServerDataSource, event, fluidRequest, that, match) {
        // TODO: Flatten out this horrid mess with async ginger world
        that.withSession(function (session, token) {
            lifecycleManagerServerDataSource.set({
                operation: "update",
                token: token
            }, match, function (response) {
                if (response.success) {
                    // Update the session.
                    session.preferences = fluidRequest.data;
                }
                gpii.request.flowManager.logAndNotify("Lifecycle manager returned: ", event)(response);
            });
        });
    };

})();
