/*!
GPII Data Source

Copyright 2012 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        fs = require("fs"),
        http = require("http"),
        url = require("url"),
        when = require("when"),
        eUC = "encodeURIComponent:";
        
    fluid.defaults("gpii.dataSource", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        components: {
            urlExpander: {
                type: "gpii.urlExpander"
            }
        },
        invokers: {
            get: "gpii.dataSource.get",
            resolveUrl: "gpii.dataSource.resolveUrl",
            handleError: "gpii.dataSource.handleError"
        },
        nickName: "dataSource", // framework bug FLUID-4636 - this is not resolved
        termMap: {},
        writable: false,
        writeMethod: "POST",
        preInitFunction: "gpii.dataSource.preInit"
    });
    
    fluid.defaults("gpii.dataSource.URL", {
        gradeNames: ["gpii.dataSource", "autoInit"]
    });

    fluid.defaults("gpii.dataSource.CouchDB", {
        gradeNames: ["gpii.dataSource", "autoInit"],
        writeMethod: "PUT"
    });

    gpii.dataSource.preInit = function (that) {
        that.nickName = "dataSource"; // work around FLUID-4636
        if (that.options.writable) {
            that.options.invokers.set = "gpii.dataSource.set";
        }
    };

    fluid.demands("gpii.dataSource.get", "gpii.dataSource.URL", {
        funcName: "gpii.dataSource.URL.all",
        args: [
            "{dataSource}",
            "get",
            "{arguments}.0",
            "{arguments}.1"
        ]
    });

    fluid.demands("gpii.dataSource.set", "gpii.dataSource.URL", {
        funcName: "gpii.dataSource.URL.all",
        args: [
            "{dataSource}",
            "set",
            "{arguments}.0",
            "{arguments}.1",
            "{arguments}.2"
        ]
    });

    fluid.demands("gpii.dataSource.get", "gpii.dataSource.CouchDB", {
        funcName: "gpii.dataSource.URL.all",
        args: [
            "{dataSource}",
            "get",
            "{arguments}.0",
            "{arguments}.1"
        ]
    });

    fluid.demands("gpii.dataSource.set", "gpii.dataSource.CouchDB", {
        funcName: "gpii.dataSource.URL.all",
        args: [
            "{dataSource}",
            "set",
            "{arguments}.0",
            "{arguments}.1",
            "{arguments}.2"
        ]
    });

    fluid.demands("gpii.dataSource.resolveUrl", null, {
        args: [
            "{urlExpander}.expand",
            "{dataSource}.options.url",
            "{dataSource}.options.termMap",
            "{arguments}.0"
        ]
    });

    fluid.demands("gpii.dataSource.handleError", "gpii.dataSource.CouchDB", {
        funcName: "gpii.dataSource.handleError",
        args: ["{gpii.requests}", "{arguments}.0"]
    });

    fluid.demands("gpii.dataSource.handleError", "gpii.dataSource.URL", {
        funcName: "gpii.dataSource.handleError",
        args: ["{gpii.requests}", "{arguments}.0"]
    });

    var processDataWrapper = function (deferred, responseParser) {
        return function (data) {
            data = typeof data === "string" ? JSON.parse(data) : data;
            if (data && data.isError) {
                deferred.reject(data);
            }
            if (responseParser) {
                data = typeof responseParser === "string" ?
                    fluid.invokeGlobalFunction(responseParser, [data]) :
                    responseParser(data);
            }
            return data;
        };
    };

    var urlAll = function (path, method, deferred, processData, model) {
        var urlObj = url.parse(path, true),
            opts = {
                host: urlObj.hostname,
                port: parseInt(urlObj.port, 10),
                path: urlObj.path,
                method: method
            };
        if (model) {
            opts.headers = {
                "Content-Type": "application/json",
                "Content-Length": model.length
            };
        }
        var req = http.request(opts, function (res) {
            var data = "";
            res.setEncoding("utf8");
            res.on("data", function (chunk) {
                data += chunk;
            });
            res.on("end", function () {
                deferred.resolve(processData(data));
            });
        });
        req.on("error", function (error) {
            deferred.reject({
                isError: true,
                message: error.message
            });
        });
        req.end(model);
        return req;
    };

    var fsAll = function (fileName, method, deferred, processData, model) {
        var args = [fileName];
        if (model) {
            args.push(model);
        }
        args.push("utf8");
        args.push(function (error, data) {
            if (error) {
                deferred.reject({
                    isError: true,
                    message: error.message
                });
                return;
            }
            deferred.resolve(processData(data || model));
        });
        fs[method + "File"].apply(null, args);
    };

    var stringifyModel = function (model) {
        if (!model) {
            return;
        }
        return typeof model === "string" ? model : JSON.stringify(model);
    };

    gpii.dataSource.isFileProtocol = function(uri) {
        return /^file:\/\//.test(uri);
    };

    gpii.dataSource.URL.all = function (dataSource, method) {
        var deferred = when.defer(),
            promise = deferred.promise,
            request = fluid.resolveEnvironment("{request}", {
                fetcher: fluid.makeEnvironmentFetcher()
            }),
            errback = gpii.callbackWrapper(request, function (error) {
                dataSource.handleError(error);
            }),
            processData = processDataWrapper(deferred, dataSource.options.responseParser),
            func = urlAll,
            args = fluid.remove_if(fluid.makeArray(arguments).slice(2), function (arg) {
                return !!!arg;
            }),
            directModel = {},
            url, isFileProtocol, model, callback, i, arg;

        for (i = args.length - 1; i > -1; --i) {
            arg = args[i];
            if (typeof arg === "function") {
                callback = arg;
            } else {
                if (model || (i === 0 && method === "get")) {
                    directModel = arg;
                    continue;
                }
                model = arg;
            }
        }

        if (method === "set" && !model) {
            dataSource.handleError({
                isError: true,
                message: "No payload provided on set."
            });
            return promise;
        }
        model = stringifyModel(method === "set" ? model : undefined);
        url = dataSource.resolveUrl(directModel);
        isFileProtocol = gpii.dataSource.isFileProtocol(url);
        method = method === "get" ? "GET" : dataSource.options.writeMethod;
        if (isFileProtocol) {
            func = fsAll;
            url = url.substring(7);
            method = method === "GET" ? "read" : "write";
        }

        if (callback) {
            promise.then(callback, errback);
        } else {
            promise.otherwise(errback);
        }

        func.apply(null, [url, method, deferred, processData, model]);

        return promise;
    };

    gpii.dataSource.handleError = function (requests, data) {
        requests.events.onError.fire(data);
    };

    gpii.dataSource.resolveUrl = function (expand, url, termMap, directModel) {
        var map = fluid.copy(termMap);
        map = fluid.transform(map, function (entry) {
            var encode = false;
            if (entry.indexOf(eUC) === 0) {
                encode = true;
                entry = entry.substring(eUC.length);
            }
            if (entry.charAt(0) === "%") {
                entry = fluid.get(directModel, entry.substring(1));
            }
            if (encode) {
                entry = encodeURIComponent(entry);
            }
            return entry;
        });
        var replaced = fluid.stringTemplate(url, map);
        replaced = expand(replaced);
        return replaced;
    };

})();