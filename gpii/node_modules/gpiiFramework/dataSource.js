/*!
GPII Data Source

Copyright 2012 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        fs = require("fs"),
        http = require("http"),
        url = require("url"),
        eUC = "encodeURIComponent:";
        
    fluid.defaults("gpii.dataSource", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        components: {
            urlResolver: {
                type: "gpii.dataSource.urlResolver"
            },
            errback: {
                type: "gpii.dataSource.errback"
            },
            modelParser: {
                type: "gpii.dataSource.modelParser"
            }
        },
        invokers: {
            get: "gpii.dataSource.get"
        },
        nickName: "dataSource", // framework bug FLUID-4636 - this is not resolved
        termMap: {},
        writable: false,
        writeMethod: "POST",
        preInitFunction: "gpii.dataSource.preInit"
    });

    fluid.defaults("gpii.dataSource.modelParser", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        invokers: {
            stringify: "gpii.dataSource.modelParser.stringify",
            parse: "gpii.dataSource.modelParser.parse"
        }
    });

    fluid.demands("gpii.dataSource.modelParser.parse", "gpii.dataSource.modelParser", {
        args: [{
            responseParser: "{dataSource}.options.responseParser",
            errback: "{errback}"
        }, "{arguments}.0"]
    });

    gpii.dataSource.modelParser.parse = function (options, data) {
        var responseParser = options.responseParser;
        data = typeof data === "string" ? JSON.parse(data) : data;
        if (data && data.isError) {
            options.errback.events.onError.fire(data);
        }
        if (responseParser) {
            data = typeof responseParser === "string" ?
                fluid.invokeGlobalFunction(responseParser, [data]) :
                responseParser(data);
        }
        return data;
    };

    fluid.demands("gpii.dataSource.modelParser.stringify", "gpii.dataSource.modelParser", {
        args: "{arguments}.0"
    });

    gpii.dataSource.modelParser.stringify = function (model) {
        if (!model) {
            return;
        }
        return typeof model === "string" ? model : JSON.stringify(model);
    };

    fluid.defaults("gpii.dataSource.errback", {
        gradeNames: ["autoInit", "fluid.eventedComponent"],
        events: {
            onError: null
        },
        listeners: {
            onError: "{that}.handleError"
        },
        preInitFunction: "gpii.dataSource.errback.preInit",
        invokers: {
            handleError: "gpii.dataSource.errback.handleError"
        }
    });

    gpii.dataSource.errback.preInit = function (that) {
        that.handleError = function (data) {
            that.handleError(data);
        };
    };

    fluid.demands("gpii.dataSource.errback.handleError", "gpii.dataSource.errback", {
        args: [
            "{callbackWrapper}",
            "{requestProxy}",
            "{arguments}.0"
        ]
    });

    gpii.dataSource.errback.handleError = function (callbackWrapper, requestProxy, data) {
        var fireOnError = callbackWrapper.wrap(requestProxy.events.onError.fire);
        fireOnError(data);
    };

    fluid.defaults("gpii.dataSource.urlResolver", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        components: {
            urlExpander: {
                type: "gpii.urlExpander"
            }
        },
        invokers: {
            resolve: "gpii.dataSource.urlResolver.resolve"
        }
    });

    fluid.demands("gpii.dataSource.urlResolver.resolve", "gpii.dataSource.urlResolver", {
        args: [
            "{urlExpander}.expand",
            "{dataSource}.options.url",
            "{dataSource}.options.termMap",
            "{arguments}.0"
        ]
    });

    gpii.dataSource.urlResolver.resolve = function (expand, url, termMap, directModel) {
        var map = fluid.copy(termMap);
        map = fluid.transform(map, function (entry) {
            var encode = false;
            if (entry.indexOf(eUC) === 0) {
                encode = true;
                entry = entry.substring(eUC.length);
            }
            if (entry.charAt(0) === "%") {
                entry = fluid.get(directModel, entry.substring(1));
            }
            if (encode) {
                entry = encodeURIComponent(entry);
            }
            return entry;
        });
        var replaced = fluid.stringTemplate(url, map);
        replaced = expand(replaced);
        return replaced;
    };
    
    fluid.defaults("gpii.dataSource.URL", {
        gradeNames: ["gpii.dataSource", "autoInit"]
    });

    fluid.defaults("gpii.dataSource.CouchDB", {
        gradeNames: ["gpii.dataSource", "autoInit"],
        writeMethod: "PUT",
        finalInitFunction: "gpii.dataSource.CouchDB.finalInit"
    });

    gpii.dataSource.CouchDB.finalInit = function (that) {
        if (!that.options.writable) {
            return;
        }
        var originalSet = that.set;
        that.set = function (directModel, model, callback) {
            var couchDBCallback = function (resp) {
                if (resp.ok) {
                    resp = fluid.model.transformWithRules(resp, {
                        "_rev": "rev",
                        "_id": "id"
                    });
                }
                callback(resp);
            };
            originalSet.apply(null, [directModel, model, couchDBCallback]);
        };
    };

    gpii.dataSource.preInit = function (that) {
        that.nickName = "dataSource"; // work around FLUID-4636
        if (that.options.writable) {
            that.options.invokers.set = "gpii.dataSource.set";
        }
    };

    fluid.demands("gpii.dataSource.get", "gpii.dataSource.URL", {
        funcName: "gpii.dataSource.URL.handle",
        args: [{
            urlResolver: "{urlResolver}",
            errback: "{errback}",
            modelParser: "{modelParser}"
        }, "{arguments}.0", "{arguments}.1"]
    });

    fluid.demands("gpii.dataSource.set", "gpii.dataSource.URL", {
        funcName: "gpii.dataSource.URL.handle",
        args: [{
            urlResolver: "{urlResolver}",
            errback: "{errback}",
            modelParser: "{modelParser}",
            writeMethod: "{dataSource}.options.writeMethod"
        }, "{arguments}.0", "{arguments}.2", "{arguments}.1"]
    });

    fluid.demands("gpii.dataSource.get", "gpii.dataSource.CouchDB", {
        funcName: "gpii.dataSource.URL.handle",
        args: [{
            urlResolver: "{urlResolver}",
            errback: "{errback}",
            modelParser: "{modelParser}"
        }, "{arguments}.0", "{arguments}.1"]
    });

    fluid.demands("gpii.dataSource.set", "gpii.dataSource.CouchDB", {
        funcName: "gpii.dataSource.URL.handle",
        args: [{
            urlResolver: "{urlResolver}",
            errback: "{errback}",
            modelParser: "{modelParser}",
            writeMethod: "{dataSource}.options.writeMethod"
        }, "{arguments}.0", "{arguments}.2", "{arguments}.1"]
    });

    gpii.dataSource.URL.handle = function (options, directModel, callback, model) {
        var url = options.urlResolver.resolve(directModel),
            isFileProtocol = gpii.dataSource.isFileProtocol(url),
            func = gpii.dataSource.URL.handle.url;
        if (isFileProtocol) {
            url = url.substring(7);
            func = gpii.dataSource.URL.handle.fs;
        }
        model = options.modelParser.stringify(model);
        func.apply(null, [url, options, callback, model]);
    };

    gpii.dataSource.URL.handle.url = function (path, options, callback, model) {
        var urlObj = url.parse(path, true),
            opts = {
                host: urlObj.hostname,
                port: parseInt(urlObj.port, 10),
                path: urlObj.path,
                method: "GET"
            };
        if (model) {
            opts.headers = {
                "Content-Type": "application/json",
                "Content-Length": model.length
            };
            opts.method = options.writeMethod;
        }
        var req = http.request(opts, function (res) {
            var data = "";
            res.setEncoding("utf8");
            res.on("data", function (chunk) {
                data += chunk;
            });
            res.on("end", function () {
                data = options.modelParser.parse(data);
                callback(data);
            });
        });
        req.on("error", function (error) {
            options.errback.events.onError.fire({
                isError: true,
                message: error.message
            });
        });
        req.end(model);
        return req;
    };

    gpii.dataSource.URL.handle.fs = function (fileName, options, callback, model) {
        var method = "readFile",
            args = [fileName, "utf8", function (error, data) {
                if (error) {
                    options.errback.events.onError.fire({
                        isError: true,
                        message: error.message
                    });
                    return;
                }
                data = options.modelParser.parse(data || model);
                callback(data);
            }];
        if (model) {
            method = "writeFile";
            args.splice(1, 0, model);
        }
        fs[method].apply(null, args);
    };

    gpii.dataSource.isFileProtocol = function(uri) {
        return /^file:\/\//.test(uri);
    };

    fluid.defaults("gpii.callbackWrappingDataSource", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        components: {
            callbackWrapper: "{callbackWrapper}",
            rawSource: {
                type: "gpii.dataSource"
            }
        },
        finalInitFunction: "gpii.callbackWrappingDataSource.finalInit"
    });

    gpii.callbackWrappingDataSource.finalInit = function (that) {
        fluid.each(["get", "set"], function (method) {
            that[method] = function () {
                var args = fluid.makeArray(arguments),
                    callback = args[args.length - 1];
                args[args.length - 1] = that.callbackWrapper.wrap(callback);
                that.rawSource[method].apply(null, args);
            };
        });
    };

})();