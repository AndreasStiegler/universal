/*
* Context Manager
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* global require */
(function () {
    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        $ = fluid.registerNamespace("jQuery");

    fluid.registerNamespace("gpii.contextManager");

    fluid.defaults("gpii.contextManager", {
        gradeNames: ["fluid.eventedComponent", "autoInit"],
        members: {
            currentContext: {}
        },
        components: {
            transformer: {
                type: "gpii.transformer"
            },
            lifecycleManager: {
                type: "gpii.lifecycleManager"
            }
        },
        invokers: {
            evaluateMatch: {
                funcName: "gpii.contextManager.evaluateMatch",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            },
            reEvaluateConditions: {
                funcName: "gpii.contextManager.reEvaluateConditions",
                args: [ "{that}", "{flowManager}" ]
            }
        }
    });

    fluid.defaults("kettle.requests.request.handler.contextChange", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        invokers: {
            handle: {
                funcName: "gpii.contextManager.contextChange",
                args: ["{flowManager}.contextManager", "{requestProxy}", "{request}.req.body"],
                dynamic: true
            }
        }
    });

    gpii.contextManager.contextChange = function (contextManager, requestProxy, body) {
        // add the new context to the existing contexts:
        var currentContext = contextManager.currentContext;
        fluid.each(body, function (newValue, contextId) {
            currentContext[contextId] = newValue;
        });
        fluid.log("Context has been updated to: "+JSON.stringify(currentContext, null, 4));
        // re-evaluate the context and matchData based on the new context
        contextManager.reEvaluateConditions();
        requestProxy.events.onSuccess.fire();
    }

    gpii.contextManager.findActiveContexts = function (contextManager, matchData) {
        var activeContexts = [ "gpii-default" ];
        // do nothing if there is no NP set yet
        fluid.each(matchData.inferredConfiguration, function (content, contextId) {
            if (content.conditions === undefined) {
                return;
            }
            // massage conditions to be proper transform specs:
            var condArray = [];
            fluid.each(content.conditions, function (condition) {
                var entry = fluid.copy(condition);
                entry.type = gpii.contextManager.utils.transformTypeLookup[condition.type];
                if (entry.type === undefined) {
                    console.log("ERROR: Failed to find the condition type: " + condition.type + " - Ignoring that conditional block");
                    condArray = false;
                    return;
                }
                condArray.push({
                    transform: entry
                });
            });
            var result = fluid.model.transformWithRules(contextManager.currentContext, { evaluations: condArray });
            console.log("RESULT: "+result);
            //if we only have 'true' entries after evaluation
            if (result.evaluations && $.inArray(false, result.evaluations) === -1) {
                // TODO Take priorities into account
                // prepend the entry
                activeContexts.unshift(contextId);
            }
        });
        return activeContexts;
    };

    gpii.contextManager.reEvaluateConditions = function (contextManager, flowManager) {
        // find logged in users
        var activeSessions = flowManager.lifecycleManager.getActiveSessionTokens();
        // if none is logged in, do nothing
        if (activeSessions.length === 0) {
            return;
        }
        var activeSession = flowManager.lifecycleManager.getSession(activeSessions);
        var newActiveContexts = gpii.contextManager.findActiveContexts(contextManager, activeSession.matchedData);
        console.log("New active contexts: " + newActiveContexts);
        if (newActiveContexts[0] === activeSession.appliedContext) {
            console.log("Same context as before so doing nothing");
            return;
        }
        var sessionChanges = {
            appliedContext: newActiveContexts[0],
            appliedConfiguration: activeSession.matchedData.inferredConfiguration[newActiveContexts[0]]
        }
        var lifecycleInstructions = flowManager.transformer.settingsHandlerToLifecycle(sessionChanges.appliedConfiguration, activeSession.solutionsRegistry);

        flowManager.lifecycleManager.update({ userToken: activeSession.userToken }, lifecycleInstructions, function (response) {
            if (response.success) {
                $.extend(true, activeSession, sessionChanges);
            }
            console.log("Successfully updated configuration triggered by context changes");
            //gpii.request.flowManager.logAndNotify("Lifecycle manager returned: ", event)(response);
        });
        //else find active contexts and save
        //pick highest priority active context and save
        //send to lifecycle manager
    }

    /*
     * Function to take the full output of a matchmaking process, evaluate the current context,
     * and decide which context should currently be used. The application block for this context
     * is passed on in the event passed as parameter.
     *
     * @that (Object) - gpii.contextManager object
     * @matchData (Object) - the output of a matchmaking process, or an object that is in a
     *      similar format
     * @fullMMData (Object) - the original data sent to the matchmakers. This is amongst other used
     *      when solutionsRegistry data is needed, etc.
     * @event (Object) - the event to be fired with the result of this function - ie. the relevant
     *      part of the `matchData` block, based on the current context
     */
    gpii.contextManager.evaluateMatch = function (that, matchData, fullMMData, event) {
        console.log("gpii.contextManager.evaluateMatch called");
        // if (!matchData.inferredConfiguration["gpii-default"]) {
        //     // should be: if no solutions matches the decided context
        //     event.fire({}, fullMMData);
        //     return;
        // }
        // TODO KASPER: call the reporters to retrieve data about the current context
        var toSession = fullMMData;

        var activeContexts = gpii.contextManager.findActiveContexts(that, matchData);
        console.log("Active contexts: " + activeContexts);

        // save highest priority context as the applied one
        toSession.appliedContext = activeContexts[0];
        toSession.appliedConfiguration = matchData.inferredConfiguration[toSession.appliedContext] || {};
        toSession.matchedData = matchData;

        // TODO: consider moving this transformation call elsewhere
        var lifecycleInstructions = that.transformer.settingsHandlerToLifecycle(toSession.appliedConfiguration, toSession.solutionsRegistry);

        event.fire(lifecycleInstructions, toSession);

                // that.currentContext = {
        //     data: {
        //         "http://registry.gpii.net/terms/environment/brightness": 60,
        //         "http://registry.gpii.net/terms/environment/sound": -6,
        //         "http://registry.gpii.net/terms/environment/timeOfDay": "18:29:00",
        //         "http://registry.gpii.net/terms/environment/location": {
        //             lat: "43.999N",
        //             "long": "74.382W"
        //         }
        //     }
        // };

    };
})();