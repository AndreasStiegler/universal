/*
* Context Manager
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* global require */
(function () {
    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        $ = fluid.registerNamespace("jQuery");

    fluid.registerNamespace("gpii.contextManager");

    fluid.defaults("gpii.contextManager", {
        gradeNames: ["fluid.modelRelayComponent", "fluid.eventedComponent", "autoInit"],
        members: {
            temporalIntervalID: null
        },
        components: {
            transformer: {
                type: "gpii.transformer"
            }
        },
        invokers: {
            evaluateMatch: {
                funcName: "gpii.contextManager.evaluateMatch",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            }
        },
        modelListeners: {
            currentContext: {
                funcName: "gpii.contextManager.evaluateConditions",
                args: [ "{that}", "{lifecycleManager}", "{change}.value" ]
            }
        },
        listeners: {
            onCreate: "gpii.contextManager.startTemporalEnvironmentReporter",
            onDestroy: "gpii.contextManager.stopTemporalEnvironmentReporter"
        }
    });

    fluid.defaults("kettle.requests.request.handler.environmentChanged", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        invokers: {
            handle: {
                funcName: "gpii.contextManager.handleEnvironmentChanged",
                args: ["{flowManager}.contextManager", "{request}.req.body", "{requestProxy}.events.onSuccess"],
                dynamic: true
            }

        }
    });

    /**
     * Request handler for URL /environmentChanged. Forwards the content to environmentChanged
     * function and fires the onSuccess event.
     *
     * @that {Object} The context manager component
     * @body {Object} the body of the request. It is expected to contain only key-value pairs
     *      of context variables, and optionally a 'timestamp' key (and associated value) which
     *      will not be considered part of the current context
     * @onSuccess {Object} onSuccess event - will be fired with empty content
     **/
    gpii.contextManager.handleEnvironmentChanged = function (that, body, onSuccess) {
        gpii.contextManager.environmentChanged(that, body);
        onSuccess.fire();
    };

    /**
     * Responsible for weeding out any information from the request body that is not strictly
     * context variables and then notifying the applier.
     *
     * @that {Object} The context manager component
     * @body {Object} the body of the request. It is expected to contain only key-value pairs
     *      of context variables, and optionally a 'timestamp' key (and associated value) which
     *      will not be considered part of the current context
     **/
    gpii.contextManager.environmentChanged = function (that, body) {
        var newContext = fluid.copy(body);
        delete newContext.timestamp;
        fluid.log("Updating context with: " + JSON.stringify(newContext, null, 4));
        that.applier.change("currentContext", newContext);
    };



    /**
     * Function to start the "Temporal reporter". Will report timerelated contexts every 20 seconds.
     * It reports both the timestamp and timeOfDay context variables via manual calls to the
     * gpii.contextManager.environmentChanged function
     *
     * TODO: The timezone here is retrieved based on the system time - the geographical location
     * of the user is not taken into account (unless the OS does so by default) - see GPII-1105
     *
     * @that {Object} The context manager object
     **/
    gpii.contextManager.startTemporalEnvironmentReporter = function (that) {
        that.intervalID = setInterval(function () {
            var date = new Date();
            gpii.contextManager.environmentChanged(that, {
                // ms since UTC epoch, eg: 1421066816897
                "http://registry.gpii.net/common/environment/timestamp": date.getTime(),
                // time of day, eg: "18:30"
                "http://registry.gpii.net/common/environment/timeOfDay": date.getHours() + ":" + date.getMinutes()
            });
        }, 20000); //report time every 20 seconds
    };

    /**
     * Triggered on destruction of the context manager component. Stops the temporal reporters
     * time reports
     *
     * @that {Object} The context manager object
     **/
    gpii.contextManager.stopTemporalEnvironmentReporter = function (that) {
        clearInterval(that.intervalID);
    };

    /**
     * This function is listening to the changeApplier of the contextManager ("currentContext" path)
     *
     * On changes to the currentContext part of the model it will:
     * 1) parse the context against the currently logged in users' conditions
     * 2) if the new calculated active context is different from the currently applied context,
     *    the lifecycle managers update functionality will be called and the applied context and
     *    configuration will be stored in the active session of the lifecycle manager.
     *
     * @that {Object} The context manager object
     * @lifecycleManager {Object} the lifecycleManager component from which the current
     *    session will be retrieved
     * @context {Object} The model as reporterd by the changeApplier (ie. the content of
     *    that.model.currentContext)
     **/
    gpii.contextManager.evaluateConditions = function (that, lifecycleManager, context) {
        // find logged in users
        var activeSessions = lifecycleManager.getActiveSessionTokens();
        // if none is logged in, do nothing
        if (activeSessions.length === 0) {
            return;
        }
        var activeSession = lifecycleManager.getSession(activeSessions);
        var newActiveContexts = gpii.contextManager.utils.findActiveContexts(context, activeSession.matchedData);
        console.log("New active contexts: " + newActiveContexts);
        if (newActiveContexts[0] === activeSession.appliedContext) {
            console.log("Same context as before (" + activeSession.appliedContext + ") so doing nothing");
            return;
        }
        var sessionChanges = {
            appliedContext: newActiveContexts[0],
            appliedConfiguration: activeSession.matchedData.inferredConfiguration[newActiveContexts[0]]
        };
        var lifecycleInstructions = that.transformer.settingsHandlerToLifecycle(sessionChanges.appliedConfiguration, activeSession.solutionsRegistry);

        lifecycleManager.update({ userToken: activeSession.userToken }, lifecycleInstructions, function (response) {
            if (response.success) {
                $.extend(true, activeSession, sessionChanges);
            }
            console.log("Successfully updated configuration triggered by context changes");
        });
    };

    /*
     * Function to take the full output of a matchmaking process, evaluate the current context,
     * and decide which context should currently be used. The application block for this context
     * is passed on in the event passed as parameter.
     *
     * @that (Object) - gpii.contextManager object
     * @matchedData (Object) - the output of a matchmaking process, or an object that is in a
     *      similar format
     * @toSession (Object) - the original data sent to the matchmakers. This is amongst other used
     *      when solutionsRegistry data is needed, etc.
     * @event (Object) - the event to be fired with the result of this function - ie. the relevant
     *      part of the `matchData` block, based on the current context
     */
    gpii.contextManager.evaluateMatch = function (that, matchedData, toSession, event) {
        console.log("gpii.contextManager.evaluateMatch called");

        var activeContexts = gpii.contextManager.utils.findActiveContexts(fluid.get(that.model, "currentContext"), matchedData);

        // save highest priority context as the applied one
        toSession.appliedContext = activeContexts[0];
        toSession.appliedConfiguration = matchedData.inferredConfiguration[toSession.appliedContext] || {};
        toSession.matchedData = matchedData;

        // TODO: consider moving this transformation call elsewhere
        var lifecycleInstructions = that.transformer.settingsHandlerToLifecycle(toSession.appliedConfiguration, toSession.solutionsRegistry);

        event.fire(lifecycleInstructions, toSession);
    };
})();