/*
* Context Manager
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* global require */
(function () {
    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        when = when || require("when"),
        path = require("path");

    fluid.registerNamespace("gpii.contextManager");

    fluid.defaults("gpii.contextManager", {
        gradeNames: ["kettle.app", "autoInit"],
        currentContext: {},
        components: {
            ontologyHandler: {
                "type": "gpii.ontologyHandler"
            }
        },
        handlers: {
            // contextChanged: {
            //     route: "/match",
            //     type: "post"
            // }, //TODO
        },
        invokers: {
            evaluateMatch: {
                funcName: "gpii.contextManager.evaluateMatch",
                args: [ "{that}", "{arguments}.0", "{arguments}.1", "{that}.events.onMatchEvaluated" ]
            }
        },
        events: {
            onFinishedMatch: null,
            onMatchEvaluated: null
        },
        listeners: {
            onFinishedMatch: "{that}.evaluateMatch",
        }
    });

    gpii.contextManager.evaluateMatch = function (that, matchData, fullMMData, event) {
        //todo: probably need to store the matchData and fullMMData somewhere, along with last context

        // var transform = matchMaker.transformer.transformSettings,
        //     strategy = fluid.getGlobalValue(matchMaker.options.strategy);
        console.log("=====================NO ONE IS SAFE=======================");
        console.log(matchData+", "+fullMMData);
        //TODO: call the reporters to retrieve data about the current context
        that.currentContext = {
            data: {
                "http://registry.gpii.net/terms/environment/brightness": 60, // lux
                "http://registry.gpii.net/terms/environment/sound": -6, // dB
                "http://registry.gpii.net/terms/environment/timeOfDay": "18:29:00",
                "http://registry.gpii.net/terms/environment/location": { // <-- idem spatial
                    lat: "43.999N", // GMT
                    long: "74.382W"
                }
            }
        }

        //TODO: evaluate context based on matchData and envContext
        var activeContext = matchData.inferredConfiguration["gpii-default"];
        that.currentContext.id = "gpii-default";

        event.fire(activeContext, fullMMData);

        return;
    };

    gpii.contextManager.match = function (ontologyHandler, payload, disposeStrategy) {
        //var ontologized = gpii.matchMaker.supplyOntologizedPreferences(preferences, inverseCapabilities);
        //TODO: supplement preferences with the ones inverse
        //$.extend(true, preferences, ontologized);
        payload.hierarchicalPrefs = gpii.matchMaker.ontologizePreferences(ontologyHandler, payload.preferences, "flat", "ISO24751");

        var strategy = fluid.getGlobalValue(disposeStrategy);
        return when(gpii.matchMaker.disposeSolutions2(payload, strategy), function (disposed) {
            var togo = gpii.matchMaker.buildReturnPayload (payload, disposed);
            console.log("return payload" + JSON.stringify(togo, null, 4));
            return togo;
        });
    };

    gpii.contextManager.disposeStrategy = function (leaves, solrecs) {
        fluid.each(solrecs, function(solrec) {
            var accepted = fluid.find(leaves, function (leaf) {
                return fluid.get(solrec.skeleton, leaf, fluid.model.escapedGetConfig);
            });
            solrec.disposition = accepted? "accept" : "reject";
        });
        return solrecs;
    };
})();