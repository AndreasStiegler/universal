/*!
GPII Ontology Server

Copyright 2012 OCAD University
Copyright 2014 Raising The Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/*global require, __dirname */

//TODO KASPER: Ensure that transformations work for app specific settings + tests
//TODO KASPER: change all the NP sets to use this new format
//TODO KASPER: Change the URLs used in the raw preferences server
//TODO KASPER: Change all the URLs used by the system to use the raw preferences server
//TODO KASPER: Ensure that all tests pass with this new setup
//TODO KASPER: Do changes and pull request for any required kettle changes
(function () {

    "use strict";

    var fluid = require("infusion"),
        path = require("path"),
        gpii = fluid.registerNamespace("gpii"),
        when = fluid.require("when", require),
        $ = fluid.registerNamespace("jQuery"),
        fs = require("fs");

    fluid.require("kettle", require);

    fluid.defaults("gpii.ontologyHandler", {
        gradeNames: ["fluid.littleComponent", "autoInit"],
        invokers: {
            get: {
                funcName: "gpii.ontologyHandler.get",
                args: [ "{arguments}.0", "{arguments}.1", "{arguments}.2", "{that}.ontologySource", "{that}" ]
            }
        },
        ontologySourceList: "%root/../../../testData/ontologies",
        ontologySourceUrl: "file://%root/../../../testData/ontologies/%name.json",
        ontologies: "",
        components: {
            ontologySource: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.simpleCallbackWrapper"],
                    url: "{that}.options.ontologySourceUrl",
                    termMap: {
                        token: "%token"
                    },
                    writable: true
                }
            },
            ontologyHandler: {
                type: "gpii.ontologyHandler"
            }
        },
        root: path.join(__dirname, "..")
    });

    gpii.ontologyHandler.finalInit = function (that) {
        //Read the list of available ontologyTransformations
        var resolved = fluid.stringTemplate(that.options.ontologySourceList, { root: that.options.root });
        that.options.ontologies = fs.readdirSync(resolved);
    };

    //TODO - should be removed or factored - just copied from gpii.request.flowmanager.logAndNotify
    gpii.ontologyHandler.logAndNotify = function (msg, event, callback) {
        return function (data) {
            fluid.log(msg, data);
            event.fire(callback ? callback(data) : data);
        };
    };

    gpii.ontologyHandler.get = function (rawPrefs, toView, successEvent, ontologySource, ontologyHandler) {
        fluid.log("Raw preferences "+rawPrefs);
        var returnSet = rawPrefs[toView] || {};

        //build a set of ontology transformations that we would like to have available
        var transformSpecs = [];
        fluid.each(rawPrefs, function (preferences, fromView) {
            if (fromView === toView)
                return;

            transformSpecs.push({from: fromView, to: toView});
        });


        gpii.ontologyHandler.evaluateOntologyTransforms(transformSpecs, ontologyHandler.options.ontologies, ontologySource, function (transforms) {
            fluid.each(transforms, function (data) {
                var transformed = fluid.model.transformWithRules(rawPrefs[data.from], data.transformation);
                fluid.log("translated from " + data.from + " to " + data.to + ", result: "+JSON.stringify(transformed, 2, null));
                $.extend(returnSet, transformed);
            });
            successEvent.fire(returnSet);
        });
    };

    gpii.ontologyHandler.evaluateOntologyTransforms = function (ontologySpecs, ontologies, ontologySource, callback) {
        var promises = [];
        var promise;
        var transformSpecs = {};

        fluid.each(ontologySpecs, function (spec) {
            var transformName = spec.from + "-" + spec.to;
            if ($.inArray(transformName+".json", ontologies) !== -1) {
                transformSpecs[transformName] = {
                    index: promises.length,
                    from: spec.from,
                    to: spec.to,
                    invert: false
                };
                promise = when(ontologySource.get({name: transformName}));
                promises.push(promise);
                return;
            }
            //else get transform the other way, to invert it later
            transformName = spec.to + "-" + spec.from;
            if ($.inArray(transformName+".json", ontologies) !== -1) {
                transformSpecs[transformName] = {
                    index: promises.length,
                    from: spec.from,
                    to: spec.to,
                    invert: true
                };
                promise = when(ontologySource.get({name: transformName}));
                promises.push(promise);
                return;
            }
        });
        when.all(promises).then(function (transforms) {
            var callbackParam = [];

            //invert those that need inversions, etc:
            fluid.each(transformSpecs, function (spec) {
                var transformation = transforms[spec.index];

                if (spec.invert) {
                    transformation = fluid.model.transform.invertConfiguration(transformation);
                }

                callbackParam.push({
                    to: spec.to,
                    from: spec.from,
                    transformation: transformation
                });
            });

            callback(callbackParam);
        });
    };
})();