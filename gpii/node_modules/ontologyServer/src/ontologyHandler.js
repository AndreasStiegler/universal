/*!
GPII Ontology Server GET Handler

Copyright 2014 Raising the floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/* global require */

(function () {
    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
        kettle = fluid.require("kettle", require),
        $ = fluid.registerNamespace("jQuery");

    fluid.registerNamespace("gpii.ontology");
    fluid.registerNamespace("gpii.ontology.get");
    fluid.registerNamespace("gpii.ontology.post");


    fluid.defaults("kettle.requests.request.handler.ontologyGet", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        invokers: {
            handle: {
                funcName: "gpii.ontology.get.request",
                args: [ "{request}", "{ontologyServer}", "{that}.events.onRawPreferences"],
                dynamic: true
            },
            getHandler: {
                funcName: "gpii.ontology.get.getHandler",
                args: [ "{arguments}.0", "{request}", "{requestProxy}", "{ontologyServer}.ontologySource", "{that}" ]
            }
        },
        events: {
            onRawPreferences: null
        },
        listeners: {
            onRawPreferences: "{that}.getHandler"
        }
    });

    gpii.ontology.get.request = function (request, ontologyServer, event) {
        if (request.req.params.token === undefined) {
            //TODO throw sensible error message
            fluid.error("Token is required on get call to the preferences server");
            return;
        }

        ontologyServer.getRawPreferences(event, request.req.params.token);
    };

    //TODO: Handle/Test with ?view=nonexistant as well as a block in the preferences for which no transform/ontology file exist
    //TODO  Handle/test with non-existant preferences set
    gpii.ontology.get.getHandler = function (rawPrefs, request, requestProxy, ontologySource, that) {
        fluid.log("Raw preferences "+rawPrefs);
        //request.req.query.view contains <VALUE> from ?view=<VALUE>
        //grab the desired view (ontology) value from parameter (default to "flat")
        var toView = (request.req.query && request.req.query.view) ? request.req.query.view : "flat";
        var returnSet = {};

        that.when(ontologySource.get({
            name: toView
        }), function (transformations) {
            fluid.each(rawPrefs, function (preferences, fromView) {
                //if the preferences block is in the desired ontology, add directly
                if (fromView === toView) {
                    $.extend(returnSet, preferences);
                    return;
                }
                //if we are unable to translate the current preferences block into the desired
                //ontology, ignore it
                if (!transformations[fromView]) {
                    //TODO fix/document/consider to this
                    return;
                }
                //get relevant ontology transformations for preferences block and run
                var transformation = transformations[fromView];
                var transformed = fluid.model.transformWithRules(preferences, transformation);
                fluid.log("translated from " + fromView + " to " + toView + ", result: "+transformed);
                $.extend(returnSet, transformed);
            });

            requestProxy.events.onSuccess.fire(returnSet);
        });
    };


    fluid.defaults("kettle.requests.request.handler.ontologyPost", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        invokers: {
            handle: {
                funcName: "gpii.ontology.post",
                args: ["{that}", "{requestProxy}", "{request}", "{ontologyServer}"],
                dynamic: true
            }
        }
    });

    gpii.ontology.post = function (that, requestProxy, request, ontologyServer) {
        var tmp = 1;
        var tmp2 = 2;
        var hello=tmp;
    };

    fluid.defaults("kettle.requests.request.handler.ontologyPut", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        invokers: {
            handle: {
                funcName: "gpii.ontology.put",
                args: ["{that}", "{requestProxy}", "{request}", "{ontologyServer}"],
                dynamic: true
            }
        }
    });



    gpii.ontology.put = function (that, requestProxy, request, ontologyServer) {
        var tmp = 1;
        var tmp2 = 2;
        var hello=tmp;
    };
})();