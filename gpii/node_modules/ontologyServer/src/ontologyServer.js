/*!
GPII Ontology Server

Copyright 2012 OCAD University

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

(function () {

    "use strict";

    var fluid = require("infusion"),
        path = require("path"),
        gpii = fluid.registerNamespace("gpii");

    fluid.require("kettle", require);
    //fluid.require("./ontologyConvertPost.js", require);
    fluid.require("./ontologyHandler.js", require);

    fluid.defaults("gpii.ontologyServer", {
        gradeNames: ["kettle.app", "autoInit"],
        handlers: {
            ontologyGet: {
                route: "/preferences/:token",
                type: "get"
            },
            ontologyPost: {
                route: "/preferences",
                type: "post"
            },
            ontologyPut: {
                route: "/preferences/:token",
                type: "put"
            }
        },
        invokers: {
            getRawPreferences: {
                funcName: "gpii.ontologyServer.getRawPreferences",
                args: ["{gpii.ontologyServer}.rawPreferencesDataSource", "{arguments}.0", "{arguments}.1"]
            }
        },
        ontologySourceUrl: "",
        root: path.join(__dirname, ".."),
        components: {
            rawPreferencesDataSource: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.simpleCallbackWrapper"],
                    url: "{gpii.ontologyServer}.options.urls.rawPreferences",
                    termMap: {
                        token: "%token"
                    }
                }
            }
        },
        distributeOptions: { //TODO: stolen from FlowManager.js:96 - perhaps it should be default in kettle
            source: "{that}.options.urlExpanderGradeNames",
            target: "{that urlExpander}.options.gradeNames"
        },
        urlExpanderGradeNames: ["kettle.urlExpander.development"]
    });

    gpii.ontologyServer.getRawPreferences = function (rawPreferencesDataSource, event, token) {
        rawPreferencesDataSource.get({
            token: token
        }, gpii.ontologyServer.logAndNotify("Fetched raw user preferences: ", event,
            function getPreferences(data) {
                return data.preferences || data;
        }));
    };

    //TODO - should be removed or factored - just copied from gpii.request.flowmanager.logAndNotify
    gpii.ontologyServer.logAndNotify = function (msg, event, callback) {
        return function (data) {
            fluid.log(msg, data);
            event.fire(callback ? callback(data) : data);
        };
    };

    fluid.defaults("gpii.ontologyServer.dev", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        components: {
            ontologySource: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.promiseCallbackWrapper"],
                    url: "{ontologyServer}.options.ontologySourceUrl",
                    termMap: {
                        name: "%name"
                    }
                }
            }
        },
        distributeOptions: { //TODO: should this block be removed?
            source: "{that}.options.urlExpanderGradeNames",
            target: "{that urlExpander}.options.gradeNames"
        },
        urlExpanderGradeNames: ["kettle.urlExpander.development"]
    });

    //OLD
    //fluid.defaults("gpii.ontologyServer.dev", {
    //     gradeNames: ["autoInit", "fluid.littleComponent"],
    //     components: {
    //         ontologySource: {
    //             type: "kettle.dataSource.URL"
    //         }
    //     },
    //     distributeOptions: {
    //         source: "{that}.options.urlExpanderGradeNames",
    //         target: "{that urlExpander}.options.gradeNames"
    //     },
    //     urlExpanderGradeNames: ["kettle.urlExpander.development"]
    // });

    // gpii.ontologyServer.responseParser = function (ontology) {
    //     return ontology.transformations;
    // };

    // fluid.defaults("gpii.ontologyServer.development", {
    //     gradeNames: ["autoInit", "fluid.littleComponent"],
    //     components: {
    //         ontologySource: {
    //             type: "kettle.dataSource.URL",
    //             options: {
    //                 gradeNames: ["kettle.dataSource.promiseCallbackWrapper"],
    //                 url: "{gpii.matchMaker}.options.ontologyServerUrl"
    //             }
    //         }
    //     },
    //     invokers: {
    //         set: {
    //             funcName: "gpii.ontologyServer.development.set",
    //             args: ["{ontologySource}", "{callbackWrapper}", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
    //         }
    //     }
    // });



    // gpii.ontologyServer.development.set = function (ontologySource, callbackWrapper, directModel, model, callback) {
    //     var preferences = model.preferences,
    //         source = gpii.ontologyServer.parsePreferences(preferences);
    //     if (source.from === source.to) {
    //         callback(preferences);
    //         return;
    //     }
    //     callback = callbackWrapper.wrap(callback);
    //     ontologySource.get(null).then(function (data) {
    //         preferences = fluid.model.transformWithRules(preferences,
    //             gpii.ontologyServer.expandTransformations(data[source.transformation].transformations));
    //         callback(preferences);
    //     });
    // };

})();