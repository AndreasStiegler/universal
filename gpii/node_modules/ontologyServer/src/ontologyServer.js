/*
 * GPII Ontology Server
 *
 * Copyright 2012 OCAD University
 *
 * Licensed under the New BSD license. You may not use this file except in
 * compliance with this License.
 *
 * The research leading to these results has received funding from the European Union's
 * Seventh Framework Programme (FP7/2007-2013)
 * under grant agreement no. 289016.
 *
 * You may obtain a copy of the License at
 * https://github.com/GPII/universal/blob/master/LICENSE.txt
 */

(function () {

    "use strict";

    var fluid = require("infusion"),
        path = require("path"),
        gpii = fluid.registerNamespace("gpii");

    fluid.require("kettle", require);
    fluid.require("./ontologyConvertPost.js", require);

    fluid.defaults("gpii.ontologyServer", {
        gradeNames: ["kettle.app", "autoInit"],
        handlers: {
            ontologyConvertPost: {
                route: "/ontology/convert/:to",
                type: "post"
            }
        },
        ontologySourceUrl: "",
        root: path.join(__dirname, ".."),
        components: {
            ontologySource: {
                type: "kettle.dataSource.CouchDB",
                options: {
                    gradeNames: ["kettle.dataSource.promiseCallbackWrapper"],
                    url: "{gpii.ontologyServer}.options.ontologySourceUrl",
                    termMap: {
                        name: "%name"
                    },
                    responseParser: "gpii.ontologyServer.responseParser"
                }
            }
        }
    });

    fluid.defaults("gpii.ontologyServer.dev", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        components: {
            ontologySource: {
                type: "kettle.dataSource.URL"
            }
        },
        distributeOptions: {
            source: "{that}.options.urlExpanderGradeNames",
            target: "{that urlExpander}.options.gradeNames"
        },
        urlExpanderGradeNames: ["kettle.urlExpander.development"]
    });

    gpii.ontologyServer.responseParser = function (ontology) {
        return ontology.transformations;
    };

    fluid.defaults("gpii.ontologyServer.development", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        components: {
            ontologySource: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.promiseCallbackWrapper"],
                    url: "{gpii.matchMaker}.options.ontologyServerUrl"
                }
            }
        },
        invokers: {
            set: {
                funcName: "gpii.ontologyServer.development.set",
                args: ["{ontologySource}", "{callbackWrapper}", "{arguments}.0", "{arguments}.1", "{arguments}.2"]
            }
        }
    });

    gpii.ontologyServer.development.set = function (ontologySource, callbackWrapper, directModel, model, callback) {
        var preferences = model.preferences,
            source = gpii.ontologyServer.parsePreferences(preferences);
        // The "source === undefined" check is a temporary fix to GPII-668, caused by a broke
        // implementation of the ontology service. This should be properly fixed along with the rest of
        // GPII-672
        if (source === undefined || source.from === source.to) {
            callback(preferences);
            return;
        }
        callback = callbackWrapper.wrap(callback);
        ontologySource.get(null).then(function (data) {
            preferences = fluid.model.transformWithRules(preferences,
                gpii.ontologyServer.expandTransformations(data[source.transformation].transformations));
            callback(preferences);
        });
    };

})();