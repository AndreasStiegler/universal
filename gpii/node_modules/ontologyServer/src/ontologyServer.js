/*!
GPII Ontology Server

Copyright 2012 OCAD University
Copyright 2014 Raising The Floor - International

Licensed under the New BSD license. You may not use this file except in
compliance with this License.

You may obtain a copy of the License at
https://github.com/gpii/universal/LICENSE.txt
*/

/*global require, __dirname */

//TODO KASPER: Ensure that transformations work for app specific settings + tests
//TODO KASPER: change all the NP sets to use this new format
//TODO KASPER: Change the URLs used in the raw preferences server
//TODO KASPER: Change all the URLs used by the system to use the raw preferences server
//TODO KASPER: Ensure that all tests pass with this new setup
//TODO KASPER: Do changes and pull request for any required kettle changes
(function () {

    "use strict";

    var fluid = require("infusion"),
        path = require("path"),
        gpii = fluid.registerNamespace("gpii"),
        when = fluid.require("when", require),
        $ = fluid.registerNamespace("jQuery"),

        fs = require("fs");

    fluid.require("kettle", require);

    fluid.defaults("gpii.ontologyServer", {
        gradeNames: ["kettle.app", "autoInit"],
        handlers: {
            ontologyGet: {
                route: "/preferences/:token",
                type: "get"
            },
            ontologyPost: {
                route: "/preferences",
                type: "post"
            },
            ontologyPut: {
                route: "/preferences/:token",
                type: "put"
            }
        },
        invokers: {
            getRawPreferences: {
                funcName: "gpii.ontologyServer.getRawPreferences",
                args: ["{gpii.ontologyServer}.rawPreferencesDataSource", "{arguments}.0", "{arguments}.1"]
            },
            setRawPreferences: {
                funcName: "gpii.ontologyServer.setRawPreferences",
                args: ["{gpii.ontologyServer}.rawPreferencesDataSource", "{arguments}.0", "{arguments}.1", "{arguments}.2" ]
            }
        },
        ontologySourceList: "",
        ontologySourceUrl: "",
        ontologies: "",
        root: path.join(__dirname, ".."),
        components: {
            rawPreferencesDataSource: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.simpleCallbackWrapper"],
                    url: "{gpii.ontologyServer}.options.urls.rawPreferences",
                    termMap: {
                        token: "%token"
                    },
                    writable: true
                }
            }
        },
        distributeOptions: { //TODO: stolen from FlowManager.js:96 - perhaps it should be default in kettle
            source: "{that}.options.urlExpanderGradeNames",
            target: "{that urlExpander}.options.gradeNames"
        },
        urlExpanderGradeNames: ["kettle.urlExpander.development"]
    });

    gpii.ontologyServer.finalInit = function (that) {
        //Read the list of available ontologyTransformations
        var resolved = fluid.stringTemplate(that.options.ontologySourceList, { root: that.options.root });
        that.options.ontologies = fs.readdirSync(resolved);
    };

    gpii.ontologyServer.getRawPreferences = function (rawPreferencesDataSource, event, token) {
        if (token === undefined) {
            fluid.fail("Token for getting preferences is undefined - aborting");
            return;
        }

        rawPreferencesDataSource.get({
            token: token
        }, gpii.ontologyServer.logAndNotify("Fetched raw user preferences: ", event,
            function getPreferences(data) {
                return data.preferences || data;
        }));
    };

    gpii.ontologyServer.setRawPreferences = function (rawPreferencesDataSource, event, body, token) {
        //if we were passed a token, that means we want to do an update, else we're creating a new NP set
        rawPreferencesDataSource.options.writeMethod = (token) ? "PUT" : "POST";

        rawPreferencesDataSource.set({token: token || ""}, body, gpii.ontologyServer.logAndNotify("Saved raw user preferences: ", event,
            function getPreferences(data) {
                return data;
        }));
    };

    //TODO - should be removed or factored - just copied from gpii.request.flowmanager.logAndNotify
    gpii.ontologyServer.logAndNotify = function (msg, event, callback) {
        return function (data) {
            fluid.log(msg, data);
            event.fire(callback ? callback(data) : data);
        };
    };

    gpii.ontologyServer.evaluateOntologyTransforms = function (ontologySpecs, ontologies, ontologySource, callback) {
        var promises = [];
        var promise;
        var transformSpecs = {};

        fluid.each(ontologySpecs, function (spec) {
            var transformName = spec.from + "-" + spec.to;
            if ($.inArray(transformName+".json", ontologies) !== -1) {
                transformSpecs[transformName] = {
                    index: promises.length,
                    from: spec.from,
                    to: spec.to,
                    invert: false
                };
                promise = when(ontologySource.get({name: transformName}));
                promises.push(promise);
                return;
            }
            //else get transform the other way, to invert it later
            transformName = spec.to + "-" + spec.from;
            if ($.inArray(transformName+".json", ontologies) !== -1) {
                transformSpecs[transformName] = {
                    index: promises.length,
                    from: spec.from,
                    to: spec.to,
                    invert: true
                };
                promise = when(ontologySource.get({name: transformName}));
                promises.push(promise);
                return;
            }
        });
        when.all(promises).then(function (transforms) {
            var callbackParam = [];

            //invert those that need inversions, etc:
            fluid.each(transformSpecs, function (spec) {
                var transformation = transforms[spec.index];

                if (spec.invert) {
                    transformation = fluid.model.transform.invertConfiguration(transformation);
                }

                callbackParam.push({
                    to: spec.to,
                    from: spec.from,
                    transformation: transformation
                });
            });

            callback(callbackParam);
        });
    };


    fluid.defaults("gpii.ontologyServer.dev", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        components: {
            ontologySource: {
                type: "kettle.dataSource.URL",
                options: {
                    gradeNames: ["kettle.dataSource.promiseCallbackWrapper"],
                    url: "{ontologyServer}.options.ontologySourceUrl",
                    termMap: {
                        name: "%name"
                    }
                }
            }
        },
        distributeOptions: { //TODO: should this block be removed?
            source: "{that}.options.urlExpanderGradeNames",
            target: "{that urlExpander}.options.gradeNames"
        },
        urlExpanderGradeNames: ["kettle.urlExpander.development"]
    });
})();