/*
* Flat Match Maker
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* global require */
(function () {
    "use strict";

    var fluid = require("infusion"),
        gpii = fluid.registerNamespace("gpii"),
         when = when || require("when"),
        path = require("path");

    fluid.registerNamespace("gpii.flatMatchMaker");

    fluid.defaults("gpii.flatMatchMaker", {
        gradeNames: ["kettle.app", "autoInit"],
        components: {
            ontologyHandler: {
                "type": "gpii.ontologyHandler"
            }
        },
        handlers: {
            matchPost: {
                route: "/match",
                type: "post"
            }
        },
        invokers: {
            match: {
                funcName: "gpii.flatMatchMaker.match",
                args: [ "{ontologyHandler}", "{arguments}.0", "{arguments}.1"]
            }
        }
    });

    fluid.defaults("kettle.requests.request.handler.matchPost", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        invokers: {
            handle: {
                funcName: "gpii.flatMatchMaker.matchPost",
                args: [ "{gpii.flatMatchMaker}", "{requestProxy}", "{request}.req.body" ],
                dynamic: true
            }
        }
    });

    gpii.flatMatchMaker.matchPost = function (flatMatchMaker, requestProxy, body) {
        // var transform = matchMaker.transformer.transformSettings,
        //     strategy = fluid.getGlobalValue(matchMaker.options.strategy);

        when(flatMatchMaker.match(body, "gpii.flatMatchMaker.disposeStrategy"), function (matchedSolutions) {
            console.log("So far so GOOOOOOOD");
            // return transform({
            //     solutions: matchedSolutions,
            //     preferences: preferences
            // });
        });
    };

    gpii.flatMatchMaker.match = function (ontologyHandler, payload, disposeStrategy) {
        //var ontologized = gpii.matchMaker.supplyOntologizedPreferences(preferences, inverseCapabilities);
        //TODO: supplement preferences with the ones inverse
        //$.extend(true, preferences, ontologized);
        var prefs = gpii.matchMaker.ontologizePreferences(ontologyHandler, payload.preferences, "flat", "ISO24751");
        payload.preferences = prefs;

        var strategy = fluid.getGlobalValue(disposeStrategy);
        return when(gpii.matchMaker.disposeSolutions2(payload, strategy), function (disposed) {
            var togo = matchMaker.buildReturnPayload (payload, disposed);

            var togo = [];
            //MOVED TO disposeSolutions2
            // fluid.each(disposed, function(solrec) {
            //     if (solrec.disposition === "accept") {
            //         togo.push(solrec.solution);
            //     }
            // });
            return togo;
        });
    };

    gpii.flatMatchMaker.disposeStrategy = function (leaves, solrecs) {
        fluid.each(solrecs, function(solrec) {
            var accepted = fluid.find(leaves, function (leaf) {
                return fluid.get(solrec.skeleton, leaf, fluid.model.escapedGetConfig);
            });
            solrec.disposition = accepted? "accept" : "reject";
        });
        return solrecs;
    };
})();