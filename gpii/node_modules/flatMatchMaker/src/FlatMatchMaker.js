/*
* Flat Match Maker
*
* Copyright 2014 Raising the Floor - International
*
* Licensed under the New BSD license. You may not use this file except in
* compliance with this License.
*
* The research leading to these results has received funding from the European Union's
* Seventh Framework Programme (FP7/2007-2013)
* under grant agreement no. 289016.
*
* You may obtain a copy of the License at
* https://github.com/GPII/universal/blob/master/LICENSE.txt
*/

/* global require */
(function () {
    "use strict";

    var fluid = fluid || require("infusion"),
        when = when || require("when"),
        gpii = fluid.registerNamespace("gpii");

    fluid.require("kettle", require);
    fluid.registerNamespace("gpii.flatMatchMaker");

    fluid.defaults("gpii.flatMatchMaker", {
        gradeNames: ["kettle.app", "autoInit"],
        components: {
            ontologyHandler: {
                "type": "gpii.ontologyHandler"
            }
        },
        handlers: {
            matchPost: {
                route: "/match",
                type: "post"
            }
        },
        invokers: {
            match: {
                funcName: "gpii.flatMatchMaker.match",
                args: [ "{ontologyHandler}", "{arguments}.0", "{arguments}.1"]
            },
            pathsToOntology2: {
                funcName: "gpii.flatMatchMaker.pathsToOntology2",
                args: [ "{ontologyHandler}", "{arguments}.0", "{arguments}.1", "{arguments}.2", "{arguments}.3" ]
            },
            disposeStrategy: {
                funcName: "gpii.flatMatchMaker.disposeStrategy",
                args: [ "{ontologyHandler}", "{arguments}.0", "{arguments}.1"]
            }
        }
    });

    fluid.defaults("kettle.requests.request.handler.matchPost", {
        gradeNames: ["autoInit", "fluid.littleComponent"],
        invokers: {
            handle: {
                funcName: "gpii.flatMatchMaker.matchPost",
                args: [ "{gpii.flatMatchMaker}", "{requestProxy}", "{request}.req.body" ],
                dynamic: true
            }
        }
    });


    gpii.flatMatchMaker.matchPost = function (flatMatchMaker, requestProxy, body) {
        when(flatMatchMaker.match(body, flatMatchMaker.disposeStrategy), function (matchedSolutions) {
            requestProxy.events.onSuccess.fire(matchedSolutions);
        });
    };

    gpii.flatMatchMaker.match = function (ontologyHandler, payload, disposeStrategy) {
        //var ontologized = gpii.matchMaker.supplyOntologizedPreferences(preferences, inverseCapabilities);
        //TODO: supplement preferences with the ones inverse
        //$.extend(true, preferences, ontologized);
        payload.hierarchicalPrefs = gpii.matchMakerFramework.hierarchicalUtils.ontologizePreferences(ontologyHandler, payload.preferences, "flat", "ISO24751");

        // var strategy = fluid.getGlobalValue(disposeStrategy);
        return when(gpii.matchMakerFramework.hierarchicalUtils.disposeSolutions2(payload, disposeStrategy, ontologyHandler), function (disposed) {
            var togo = gpii.matchMakerFramework.hierarchicalUtils.buildReturnPayload (payload, disposed);
            fluid.log("Flat Match Maker returning payload" + JSON.stringify(togo, null, 4));
            return togo;
        });
    };

    gpii.flatMatchMaker.disposeStrategy = function (ontologyHandler, leaves, solrecs) {
        //TODO: fix
        fluid.each(solrecs, function(solrec) {
            // var transformSpec = gpii.ontologyHandler.getTransformSpec(ontologyHandler.options.ontologyTransformSpecs, "flat", "ISO24751")
            // var skeleton = fluid.model.transformWithRules(solrec.skeleton, transformSpec)

            var accepted = fluid.find(leaves, function (leaf) {
                return fluid.get(solrec.skeleton, leaf, fluid.model.escapedGetConfig);
            });
            solrec.disposition = accepted? "accept" : "reject";
        });
        return solrecs;
    };
})();